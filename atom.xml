<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Guerbai&#39;s Blog</title>
  
  
  <link href="http://guerbai.github.io/atom.xml" rel="self"/>
  
  <link href="http://guerbai.github.io/"/>
  <updated>2021-11-06T08:56:06.836Z</updated>
  <id>http://guerbai.github.io/</id>
  
  <author>
    <name>Guerbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Suckless--极简主义者的Linux世界</title>
    <link href="http://guerbai.github.io/2021/11/06/suckless/"/>
    <id>http://guerbai.github.io/2021/11/06/suckless/</id>
    <published>2021-11-06T08:54:51.000Z</published>
    <updated>2021-11-06T08:56:06.836Z</updated>
    
    <content type="html"><![CDATA[<p>看DistroTube和Luke Smith的Linux视频时被他们高效简洁而炫酷的桌面与窗口操作惊到了，经过一些小小的研究了解到了Tiling Window Manager以及Suckless系列软件。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20210930011909.gif"></p><p>本文描述了如何安装Suckless系列软件，以及如何在其dwm窗口管理器下基本生存🪵</p><span id="more"></span><h2 id="Suckless"><a href="#Suckless" class="headerlink" title="Suckless"></a>Suckless</h2><p><a href="https://suckless.org/">suckless.org</a>是一个社区，我喜欢称之为“没毛病组织”😂，他们的极简主义哲学是：</p><blockquote><p>软件应该简单、清晰、最小化、可用。</p></blockquote><p>简单是Linux的哲学的核心，该组织认为当今的众多软件过于复杂和缓慢，于是开发了一系列的软件来证实这种普遍现象并不是必须的。这些软件主要面向有一定经验的进阶用户，使每个用户都可以定制自己的实际工作场景workflow。</p><p>主要包括以下几个作品：</p><ul><li>st(simple terminal)，X环境下的终端</li><li>dwm，动态窗口管理器</li><li>dmenu，用户自定义菜单，程序启动器</li><li>surf，浏览器</li><li>…</li></ul><h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>首先准备一个Linux发行版，本文以<a href="https://garudalinux.org/downloads.html">Garuda KDE Dr460nized</a>演示：</p><p><img src="https://garudalinux.org/images/garuda/download/dr460nized/garuda-dr460nized.webp"></p><p>Garuda是一个基于Arch Linux的发行版，下文中提到的一些安装选项亦是基于pacman包管理器，在其他发行版下需要更换为相应的包管理器。</p><p>下载几个软件源码到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/suckless</span><br><span class="line"><span class="built_in">cd</span> ~/suckless</span><br><span class="line">git <span class="built_in">clone</span> https://git.suckless.com/dmenu</span><br><span class="line">git <span class="built_in">clone</span> https://git.suckless.com/st</span><br><span class="line">git <span class="built_in">clone</span> https://git.suckless.com/dwm</span><br></pre></td></tr></table></figure><p>suckless软件的一个特点是只提供源码，需要用户自己使用编译安装。某些更轻量级的发行版可能会没有make命令，需要先手动安装相关依赖。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/suckless/st</span><br><span class="line">sudo make clean install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/suckless/dmenu</span><br><span class="line">sudo make clean install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/suckless/dwm</span><br><span class="line">sudo make clean install</span><br></pre></td></tr></table></figure><p>三次make命令后几个软件便已成功安装到了系统中。st是dwm环境下的默认终端，dmenu是dwm下的程序启动器，进入dwm之前需要先安装st或dmenu，否则会在dwm中寸步难行。</p><p>打开Garuda的默认终端konsole，输入dwm启动。会遭遇<code>dwm: another window manager is already running</code></p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162624.png"></p><p>在<a href="https://guerbai.github.io/2021/10/22/linux-gui-wm/">Linux发行版与GUI介绍</a>中介绍了WM与DE的关系，这是由于当前处在Garuda的桌面环境中，KDE自己的WM已经在运行，无法打开dwm。</p><p>这里需要为dwm编写启动选项，使得在登录时(login manager，Linux的一个软件)启动dwm而不启动KDE桌面环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=dwm</span><br><span class="line">Comment=Dynamic Window Manager</span><br><span class="line">Exec=/usr/local/bin/dwm</span><br><span class="line">Icon=</span><br><span class="line">Type=Application</span><br></pre></td></tr></table></figure><p>将上述内容命名为dwm.desktop保存到<code>/usr/share/xsessions</code>目录下，退出当前用户登录状态来到登录界面。左下角(其他发行版可能在其他位置)出现了选项，选择<strong>dwm</strong>后输入密码登录。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162642.png"></p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162656.png"></p><p>于是便来到了“没毛病老哥们”提供的极简主义者的Linux世界。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------------------+--------+</span><br><span class="line">| tags | title                            | status +</span><br><span class="line">+------+---------------------+------------+--------+</span><br><span class="line">|                            |                     |</span><br><span class="line">|                            |                     |</span><br><span class="line">|                            |                     |</span><br><span class="line">|                            |                     |</span><br><span class="line">|          master            |        stack        |</span><br><span class="line">|                            |                     |</span><br><span class="line">|                            |                     |</span><br><span class="line">|                            |                     |</span><br><span class="line">|                            |                     |</span><br><span class="line">+----------------------------+---------------------+</span><br></pre></td></tr></table></figure><p>dwm的区域分为如上几块，上面是状态栏，包括tags、title以及status；屏幕主要区域分为master与stack区域新打开的窗口会占据master，之前的窗口以栈的方式上下排列在stack区。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162823.png"></p><p>下面的列表一些dwm环境下的一些快捷键。</p><table><thead><tr><th>Keybinding</th><th>Action</th></tr></thead><tbody><tr><td>SHIFT+ALT+ENTER</td><td>打开st</td></tr><tr><td>SHIFT+ALT+q</td><td>退出dwm，回到login manager</td></tr><tr><td>ALT+p</td><td>打开dmenu，之后可以输入软件名比如firefox来启动软件</td></tr><tr><td>ALT+j/k</td><td>切换打开的多个window</td></tr><tr><td>SHIFT+ALT+n(1-9)</td><td>移动当前window至tag n(默认9个tags)</td></tr><tr><td>SHIFT+ALT+c</td><td>关闭当前window</td></tr><tr><td>ALT+ENTER</td><td>切换某当前window为master window</td></tr><tr><td>ALT+m/t</td><td>切换当前window为全屏/切换回来</td></tr><tr><td>ALT+n(1-9)</td><td>进入tag n</td></tr><tr><td>CTRL+SHIFT+PAGEUP/PAGEDOWN</td><td>zoom in/zoom out</td></tr><tr><td>ALT+b</td><td>toggle status bar</td></tr></tbody></table><h2 id="该如何…"><a href="#该如何…" class="headerlink" title="该如何…"></a>该如何…</h2><p>dwm下鼠标几乎变得没有作用，在桌面环境中的点击音量按钮调节系统音量等操作变得不再可行，geek们的做法是使用命令行工具，本节给出一些具体场景下的一种可行操作方式。</p><p><strong>浏览图片</strong></p><p>命令行安装sxiv，进入图片所在文件夹，输入：<code>sxiv *</code>，可以使用鼠标点击左右切换当前展示图片。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162722.png"></p><p><strong>设置壁纸</strong></p><p>命令行安装xwallpeper，确定希望设置的图片路径，比如<code>~/.config/wall.png</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xwallpaper --zoom ~/.config/wall.png</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162909.png"></p><p><strong>调节音量</strong></p><p>命令行安装pauseaudio，下列命令是几种对音量可能会做的操作：</p><table><thead><tr><th>Command</th><th>Action</th></tr></thead><tbody><tr><td>pactl set-sink-volume 0 +20%</td><td>音量增加20%</td></tr><tr><td>pactl set-sink-volume 0 -20%</td><td>音量减少20%</td></tr><tr><td>pactl set-sink-mute 0 toggle</td><td>静音切换</td></tr><tr><td>pactl get-sink-volume 0</td><td>获取当前音量值</td></tr></tbody></table><p><strong>截图</strong></p><p>命令行安装scrot，打开dmenu输入<code>scrotv</code>即可对当前桌面截图保存在当前文件夹。</p><p>若想截图特定窗口，可以加<code>-s</code>参数后用鼠标点击想要的窗口。其他具体指令的使用说明见scrot文档。</p><h2 id="st体验优化"><a href="#st体验优化" class="headerlink" title="st体验优化"></a>st体验优化</h2><p>st的实现只有2000多行C代码，自身的功能非常有限，以至于各种用户“习以为常”的能力它都没有，包括复制/粘贴、滚动等功能都是默认不支持的，毕竟”simple”。</p><p>suckless的软件不提供配置文件，所有配置项均在其源码config.def.h中，修改后需要运行<code>sudo cp config.def.h config.h &amp;&amp; sudo make clean install</code>重新编译安装。</p><p><strong>复制/粘贴</strong></p><p>在<code>~/st/config.def.h</code>的ShortCut中新增两行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; MODKEY, XK_c, clipcopy,  &#123;.i=<span class="number">0</span>&#125;&#125;,</span><br><span class="line">&#123; MODKEY, XK_v, clippaste, &#123;.i=<span class="number">0</span>&#125;&#125;,</span><br></pre></td></tr></table></figure><p>重新安装，即可以在st中使用SHIFT+CTRL+c/v来实现复制/粘贴功能。</p><p><strong>emoji</strong></p><p>st自然也不支持emoji的显示，比如<a href="https://github.com/guerbai/ohmyarch">ohmyarch</a>的README.md中有🤣，运行<code>cat README.md</code>会导致st直接crash掉，这里需要一个特定的依赖来解决此问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S libxft-bgra</span><br></pre></td></tr></table></figure><p><strong>透明化</strong></p><p>设置了漂亮的壁纸后将终端做一定程度的透明化是一种视觉上的享受。</p><p>命令行安装picom，配置文件写于~/.config/picom/picom.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">opacity-rule = [</span><br><span class="line">&quot;90:class_g = &#x27;st-256color&#x27;&quot;</span><br><span class="line">];</span><br><span class="line">wintypes:</span><br><span class="line">&#123;</span><br><span class="line">normal = &#123; blur-background = true; &#125;;</span><br><span class="line">splash = &#123; blur-background = false; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"># Fading</span><br><span class="line">fading = false;</span><br><span class="line">fade-in-step = 0.07;</span><br><span class="line">fade-out-step = 0.07;</span><br></pre></td></tr></table></figure><p>然而st自身的源码不支持透明显示，suckless提供了一些patches来增强它的功能，类似于其他软件中的插件。</p><p>复制<a href="https://st.suckless.org/patches/alpha/st-alpha-0.8.2.diff">alpha patch diff</a>至st源码目录内，运行<code>patch &lt; st-alpha-0.8.2.diff</code>后依然是重新编译安装。然后运行<code>picom -b</code>即可实现透明效果。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106162939.png"></p><p>除了alpha外，suckless还提供了其他许多的<a href="https://st.suckless.org/patches/">patches</a>来扩充功能，感兴趣可以继续探索。</p><h2 id="dmenu的想象力"><a href="#dmenu的想象力" class="headerlink" title="dmenu的想象力"></a>dmenu的想象力</h2><p>在path下的可执行文件均可被dmenu找到并运行，用户可以自行编写shell脚本置于<code>/usr/local/bin</code>文件夹下由dmenu执行。</p><p>比如实现一个关机/重启选项的简单例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">choices=<span class="string">&quot;shutdown\nreboot&quot;</span></span><br><span class="line"></span><br><span class="line">chosen=$(<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$choices</span>&quot;</span> | dmenu -i -p <span class="string">&quot;Operation:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$chosen</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    shutdown) shutdown;;</span><br><span class="line">    reboot) reboot;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>将该文件保存为sysop.sh置于PATH路径中，即可在dmenu中选择sysop这个选项并进行下一步选择。</p><p>这个脚本本身没有太多实际意义，然而有了这样的机制，其实可以实现非常非常多的功能，比如调节音量、浏览切换壁纸、快速打开浏览器标签页等等，笔者认为其定制能力与想象力要比MacOS下的Alfred要更为丰富。</p><h2 id="dwm状态栏"><a href="#dwm状态栏" class="headerlink" title="dwm状态栏"></a>dwm状态栏</h2><p>默认的dwm状态栏非常朴素，status部分只显示了<code>dwm-6.2</code>，“没毛病老哥”们提供了一个基础的改变status显示内容的机制，比如想要把<code>dwm-6.2</code>改变为hello world那么需要运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsetroot -name <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>有了这个简单的机制，便可以通过其他软件比如pauseaudio拿到当前音量信息并展示到status bar；通过date软件拿到当前时间信息并展示。</p><p>suckless官网列出了一些他人配置好的<a href="https://dwm.suckless.org/status_monitor/">dwm状态栏列表</a>，可以参考选用。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211106160407.png"></p><h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next"></a>What’s Next</h2><p>许多有经验的Linux用户都有自己的suckless软件版本，开箱即用，可以尝试使用一下他们的成熟配置进一步感觉suckless软件的魅力：</p><ul><li><a href="https://github.com/guerbai/ohmyarch">ohmyarch</a></li><li><a href="https://gitlab.com/users/dwt1/projects">DistroTube</a></li><li><a href="https://github.com/LukeSmithxyz">Luke Smith</a></li><li><a href="https://github.com/theniceboy">TheNiceBoy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;看DistroTube和Luke Smith的Linux视频时被他们高效简洁而炫酷的桌面与窗口操作惊到了，经过一些小小的研究了解到了Tiling Window Manager以及Suckless系列软件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/guerbai/scene/main/blog/20210930011909.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文描述了如何安装Suckless系列软件，以及如何在其dwm窗口管理器下基本生存🪵&lt;/p&gt;</summary>
    
    
    
    
    <category term="软件" scheme="http://guerbai.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="折腾" scheme="http://guerbai.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux发行版与GUI介绍</title>
    <link href="http://guerbai.github.io/2021/10/22/linux-gui-wm/"/>
    <id>http://guerbai.github.io/2021/10/22/linux-gui-wm/</id>
    <published>2021-10-22T08:16:36.000Z</published>
    <updated>2021-11-06T08:53:26.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GNU-Linux的诞生"><a href="#GNU-Linux的诞生" class="headerlink" title="GNU/Linux的诞生"></a>GNU/Linux的诞生</h2><p>1991年8月25日，21岁的<a href="https://zh.wikipedia.org/wiki/%E8%B5%AB%E5%B0%94%E8%BE%9B%E5%9F%BA%E5%A4%A7%E5%AD%A6">赫尔辛基大学</a>学生Linus Torvalds发布了他的开源操作系统，”Just a hobby, won’t be a big professional thing”，几年后，这个”hobby”–Linux成为了计算机历史上最重要的一个项目。</p><p>与Windows这样以盈利的操作系统不同，Linux的理念是：</p><blockquote><p>Software is like sex; it’s better when it’s free.     –Linus Torvalds</p></blockquote><span id="more"></span><p>时间再回到1983年，AT&amp;T与BSDI正因为Unix打得不可开交(<a href="https://en.wikipedia.org/wiki/Unix_wars">Unix Wars</a>)，Richard Stallman创建了GNU(GNU’s Not Unix) Project，试图建立可以替代Unix的自由与开源版本操作系统。彼时的Unix已然非常庞大，经过了几年的努力，GNU重写了许多自由软件，其中包括今天耳熟能详的Tar、Bash、Grep等。</p><p>到了90年代，GNU项目依然缺少操作系统内核。而一个完整的操作系统需要内核来连接硬件与软件，掌控CPU与内存来运行软件。此时横空出世的Linux，正是GNU所需要的。于是一个完整的替代Unix的操作系统诞生了：GNU/Linux！</p><h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><p>因为是自由软件，任何人都可以根据自已的喜好定制自已的操作系统，到目前已经有了千级别的Linux发行版。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211020013629.png"></p><p>一个Linux发行版包括：</p><ul><li>Linux内核</li><li>一系列预装软件</li><li>软件包管理器</li><li>桌面环境(optional)</li></ul><p>各发行版之间有着几大派系和千丝万缕的衍生关系，比如使用apt的Debian家族，基于Debian衍生出了Ubuntu这样对新手十分友好的发行版，而基于Ubuntu又衍生出了Kubuntu、Linux Mint等等。</p><p>此外另一大发行版派系是使用rpm/yum的Redhat家族，其中包括作为服务器常用的CentOS，以及著名的Fedora。</p><p>事实上，很多Linux发行版都会原生装配一些用户并不会使用的软件包，这不仅占用了电脑的资源，同时也会占用使用者的心力。于是又诞生了两个讲究简单和最小化原则的发行版派系：Arch与Gentoo。</p><p>完整的发行版的发展脉络及衍生关系见<a href="https://en.wikipedia.org/wiki/Linux_distribution#/media/File:Linux_Distribution_Timeline_Dec._2020.svg">维基百科</a>，看到也许会被吓一跳。</p><h2 id="GUI与X-Window-System"><a href="#GUI与X-Window-System" class="headerlink" title="GUI与X Window System"></a>GUI与X Window System</h2><p>黑乎乎的终端是Linux给人留下的刻板印象，然而作为个人日常使用来讲，用户更喜欢也更需要GUI–用户图形界面。</p><p>于是有了X Window System，它通过软件工具及架构协议来创建操作系统所用的GUI，此后逐渐扩展适用到各形各色的其他操作系统上，现在几乎所有的操作系统都能支持与使用X。</p><p>X只是工具包及架构规范，本身并无实际参与运作的实体，目前依据X的规范架构所开发撰写成的实现体中，以X.Org最为普遍且受欢迎。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211022150000.png"></p><p>X系统采用Client-Server的架构，与直觉不同的是，用户的显示器是服务端，真正在运行的软件是客户端。</p><p>理解X与X.Org存在的意义可以举一个最简单的例子：</p><p>使用VMWare安装Linux系统后往往所展示的桌面只是中间很小的一块，这时便可以使用X.Org提供的xrandr工具将分辨率设置为1920x1080来占满屏幕。</p><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><p>一个桌面环境由多个软件组成，这些软件共享同一个GUI，这些软件提供给用户视窗、文件夹、工具栏、壁纸、图标、拖放服务等内容。不同桌面环境在设计和功能上的特性会赋予其与众不同的外观和感觉。</p><p>Linux有几套常用的桌面环境，包括GNOME、KDE、Xfce等，如第二节中描述，桌面环境只是一个发行版的可选部分，同时是可以替换的。一个Linux系统完全可以同时安装多种桌面环境来进行切换。</p><p>这些桌面环境也有各自的特点和理念，比如Xfce的：</p><blockquote><p> 设计为可作为实际应用，快速加载及运行程序，并减少耗用系统资源</p></blockquote><p><strong>GNOME of Ubuntu</strong><br><img src="https://ubuntuclub.org/uploads/ubuntu-20-04-lts-scaled.jpg" alt="GNOME of Ubuntu"></p><p><strong>KDE of Manjaro</strong><br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211022151409.png" alt="KDE of Manjaro"></p><p><strong>Xfce of Artix</strong><br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211022151504.png" alt="Xfce of Artix"></p><h2 id="Window-Manager"><a href="#Window-Manager" class="headerlink" title="Window Manager"></a>Window Manager</h2><p>窗口管理器与桌面环境不同，它只是用来控制窗口位置与外观，不包括设置壁纸、调节音量等能力</p><p>各桌面环境都有自己的窗口管理器，比如GNOME的Mutter，Xfce的Xfwm4。它们为打开的软件窗口提供了最小化、最大化、关闭按钮，以及鼠标点击拖动的能力。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211022152216.png"></p><p>与上述这些需要使用电脑鼠标控制不同，在Linux用户中还有另外一种非常流行的WM: Tiling Window Manager.</p><p><strong>Bspwm of ArchCraft</strong><br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/20211022152956.png" alt="Bspwm of ArchCraft"></p><p>使用这样的WM时，打开的软件窗口不会有<em>关闭</em>等图标，也无法通过拖拽来移动位置，窗口会自动铺满屏幕并排列好位置，就像瓷砖一样，非常酷炫且高效。</p><p>值得一提的是，不需要桌面环境，只用X.Org+WM即可构建出GUI，在这种环境下比如要设置壁纸可以在终端中使用相应的工具xwallpaper，调节音量可以使用PauseAudio，是比较极客的玩法，优点是不会被预装上一堆本不需要的软件，同时会比一个完整的桌面环境占用更少的系统资源。这是一种“简单和最小化原则”的体现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/watch?v=ShcR4Zfc6Dw">Why so many distros? The Weird History of Linux</a></p><p><a href="https://coolshell.cn/articles/2322.html">UNIX传奇(上篇)</a></p><p><a href="https://zh.wikipedia.org/wiki/X%E8%A6%96%E7%AA%97%E7%B3%BB%E7%B5%B1">X窗口系统</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GNU-Linux的诞生&quot;&gt;&lt;a href=&quot;#GNU-Linux的诞生&quot; class=&quot;headerlink&quot; title=&quot;GNU/Linux的诞生&quot;&gt;&lt;/a&gt;GNU/Linux的诞生&lt;/h2&gt;&lt;p&gt;1991年8月25日，21岁的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B5%AB%E5%B0%94%E8%BE%9B%E5%9F%BA%E5%A4%A7%E5%AD%A6&quot;&gt;赫尔辛基大学&lt;/a&gt;学生Linus Torvalds发布了他的开源操作系统，”Just a hobby, won’t be a big professional thing”，几年后，这个”hobby”–Linux成为了计算机历史上最重要的一个项目。&lt;/p&gt;
&lt;p&gt;与Windows这样以盈利的操作系统不同，Linux的理念是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Software is like sex; it’s better when it’s free.     –Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="软件" scheme="http://guerbai.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="折腾" scheme="http://guerbai.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统中的排序技术</title>
    <link href="http://guerbai.github.io/2019/03/13/rank/"/>
    <id>http://guerbai.github.io/2019/03/13/rank/</id>
    <published>2019-03-13T07:59:23.000Z</published>
    <updated>2021-11-06T08:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>在工业应用中，推荐系统通常可分为两部分，召回和排序。</p><p>召回阶段对应的是之前几篇文章所讲的各种推荐算法，比如据<a href="https://medium.com/s/story/spotifys-discover-weekly-how-machine-learning-finds-your-new-music-19a41ab76efe">资料</a>所载，Spotify至少使用了三种算法来生成其广受赞誉的Discover Weekly歌单，包括：</p><ol><li>矩阵分解来学习集体智慧；</li><li>NLP处理音乐评论文章与报道；</li><li>对音频使用卷积神经网络进行分析。    </li></ol><p>这些算法各有特点，音频分析显然可以用于解决冷启动问题，NLP处理音乐评论更是可以学得专业人士的领域知识，它们各自独立运行给出自己的结果，由于独立，算法数目可增可减，亦可各自独立迭代变化。    </p><span id="more"></span><p>这个过程会从几千万item中筛选出几百或者上千的候选集，然后在排序阶段选出30首歌曲给到每位用户。这个排序可理解为一个函数，$F(user, item, context)$，输入为用户、物品、环境，输出一个0到1之间的分数，取分数最高的几首。这一过程通常称为CTR预估。</p><p>这篇文章来说一下该“函数”的常见形式及基本运作方式。</p><h2 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h2><p>最简单的是逻辑回归(Logistic Regression)，一个广义线性模型。</p><p>拿某user的用户画像(一个向量)比如<code>[3, 1]</code>，拼接上某item的物品画像比如<code>[4, 0]</code>，再加上代表context的向量<code>[0, 1, 1]</code>后得到<code>[3, 1, 4, 0, 0, 1, 1]</code>，若该user曾与该item发生过联系则label为1，这些加起来是一个正样本，同时可以将用户“跳过”的item或热门的却没有与用户产生过联系的item作为负样本，label为0，拟合如下方程:</p><p>$$<br>y = \frac{1}{1 + e ^ {- (w ^ {T}x + w_0)}}<br>$$</p><p>其中$x$即为上述向量，$w$是与x每个元素相对应的权重，$b$为截距。其损失函数为：</p><p>$$<br>loss =\sum_{(x, y) \in D}-y \log \left(y^{\prime}\right)-(1-y) \log \left(1-y^{\prime}\right)<br>$$</p><p>其中$y$为样本的label0或1，$y^{\prime}$是根据模型预测的0到1之间的数字。</p><p>通过降低此损失函数来拟合训练样本来完成模型的训练，利用模型对新的数据进行预测即完成了打分。训练过程参考sklearn的LogisticRegression很容易完成。</p><p>传统的LR只能在线下批量处理大量数据，无法有效处理大规模的在线数据流。模型更新可能要一天甚至更多，不够及时。而Google在2013提出了Follow The Regularized Leader(FTRL)，一种在线逻辑回归算法。该方法对逻辑回归的目标函数进行了修改，加上各种系统工程上的调优，使得该模型的参数可以在每一个线上数据点进行动态更新。<br>可以在网上找到不少FTRL的开源实现比如<a href="https://github.com/alexeygrigorev/libftrl-python">libftrl-python</a>。</p><h1 id="FM-FFM"><a href="#FM-FFM" class="headerlink" title="FM | FFM"></a>FM | FFM</h1><p>FM与FFM分别是Factorization Machine与Field-aware Factorization Machine的简称。</p><p>LR作为广义线性模型对特征向量与label之间的非线性关系会很苦手。这时便需要进行特征组合，比如使用线性模型来预测各种近似长方形形状的面积，两个特征为长$x_1$与宽$x_2$，那么显然并不能学到一个很好的模型，此时增加一个新的特征$x_3=x_1 * x_2$，便可以得到很好的效果。</p><p>在实际应用中，特征向量的维度是很高的，很难像上例中直接看到这种有意义的组合，考虑所有特征两两组合则线性回归方程变为：</p><p>$$<br>y(\mathbf{x})=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n} \sum_{j=i+1}^{n} w_{i j} x_{i} x_{j}<br>$$</p><p>除了原本特征的$i$个权重外还要学习各特征组合情况对应的权重，对于参数$w_{ij}$的训练，需要大量$x_i$和$x_j$都不为0的样本，然而由于one-hot编码等原因带来的稀疏性使得这个要求无法达成，那么训练样本不足便会导致$w_{ij}$的不准确，从而影响模型的质量。</p><p>解决方案是使用矩阵分解。在推荐系统中会对<code>user_item_matrix</code>做分解，为user及item学得一个低维的向量来代表自已。那么此处的情况可以与之类比，将特征组合的所有权重表示为一个形状为(i * i)的矩阵，那么$w_{ij}$即为此矩阵第i行第j列的数值，将此高维度的矩阵进行分解，可以为每个特征得到一个关于权重的隐向量$v_i$，那么$w_{i j}$使用$v_i$点乘$v_j$即可得到。此时线性方程变为：</p><p>$$<br>y(\mathbf{x})=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}<br>$$</p><p>以上模型称为因子分解机(Factorization Machine)，经过一些数学上的变换及处理，该模型可以在$O(kn)$的复杂度下进行训练和预测，是一种比较高效的模型。</p><p>在FM的基础上有人提出了Field-aware Factorization Machine。比如特征向量中有200多维来代表一个user的国家，<code>country.uk</code>和<code>country.us</code>等等，那么这200多个特征可以认为是属于一个field，区别在为特征$x_i$学习隐向量时要为每一个field都学到一个相应的隐向量，特征组合权重$w_{ij}$根据$x_i$关于$x_j$所在field的隐向量乘以$x_j$关于$x_i$所属field的隐向量而得，线性方程变为：</p><p>$$<br>y(\mathbf{x})=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i, f_{j}}, \mathbf{v}_{j, f_{i}}\right\rangle x_{i} x_{j}<br>$$</p><p>该方法效果更好，而预测时间复杂度升至$O(kn^2)$。有开源库<a href="https://github.com/guestwalk/libffm">libffm</a>的实现以供使用。</p><h2 id="GBDT-amp-LR"><a href="#GBDT-amp-LR" class="headerlink" title="GBDT &amp; LR"></a>GBDT &amp; LR</h2><p>Facebook在广告CTR预估上的做法是使用梯度提升决策树(GBDT) &amp; LR的方案。</p><p>思路是将原本要输入LR的特征向量，先经过GBDT筛选和组合，生成新的特征向量再送到LR中。如图所示：</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/a6192109ef055ff32df7541a69a9a129.jpg"></p><p>GBDT作为集成模型，会使用多棵决策树，每棵树去拟合前一棵树的残差来得到很好的拟合效果。一个样本输入到一棵树中，会根据各节点的条件往下走到某个叶子节点，将此节点值置为1，其余置为0。比如训练使用了3棵决策树，每棵决策树有5个叶子节点，样本在各树分别落到了各树从左往右的第1，2，3个节点上，则得到三个one-hot编码为<code>[1, 0, 0, 0, 0]</code>，<code>[0, 1, 0, 0, 0]</code>，<code>[0, 0, 1, 0, 0]</code>，拼接起来作为转换后的特征向量：<code>[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]</code>，输入到LR模型中得到分值。</p><p>此模型为Facebook的广告效果带来了明显的提升，在其发表的论文中，还讨论了各种工程上的实践与细节，包括GBDT与LR的更新频率，降采样的比例实践等，值得参考。实现GBDT可以使用开源的<a href="https://xgboost.readthedocs.io/en/latest/">XGBoost包</a>。</p><h2 id="Wide-amp-Deep"><a href="#Wide-amp-Deep" class="headerlink" title="Wide &amp; Deep"></a>Wide &amp; Deep</h2><p>Google在Google Play中对App的推荐排序使用了一种名为Wide &amp; Deep的深宽模型。如下图：</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/da67d0fae63cc7481e080bc41836f14e.jpg"></p><p>Wide部分就是广义的线性模型，在原本的特征基础上适当加一些特征组合，Deep部分是一个前馈神经网络，可以对一些稀疏的特征学习到一个低维的稠密向量，将Wide与Deep的信息相加，依然使用Sigmond来预测函数，表示为：</p><p>$$<br>P(Y=1 | \mathbf{x})=\sigma\left(\mathbf{w}_{w i d e}^{T}[\mathbf{x}, \phi(\mathbf{x})]+\mathbf{w}_{d e e p}^{T} a^{\left(l_{f}\right)}+b\right)<br>$$</p><p>其中$\sigma$为Sigmond函数，$W_{wide}^T$是Wide部分的权重，$\phi(\mathbf{x})$表示Wide部分的组合特征，$a^{\left(l_{f}\right)}$为Deep网络最后一层输出，$b$是线性模型的偏重。</p><p>将两个模型放到一起联合训练(不同于集成训练需要将各模型单独训练再将结果汇合)，互相弥补对方的不足(特征工程困难和可解释性差)，该模型为Google Play的在线收益相较于纯Wide模型带来了3.9%的提升。实现可参考<a href="https://github.com/tensorflow/models">tensorflow/models</a>项目。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在工业应用中，推荐系统通常可分为两部分，召回和排序。&lt;/p&gt;
&lt;p&gt;召回阶段对应的是之前几篇文章所讲的各种推荐算法，比如据&lt;a href=&quot;https://medium.com/s/story/spotifys-discover-weekly-how-machine-learning-finds-your-new-music-19a41ab76efe&quot;&gt;资料&lt;/a&gt;所载，Spotify至少使用了三种算法来生成其广受赞誉的Discover Weekly歌单，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;矩阵分解来学习集体智慧；&lt;/li&gt;
&lt;li&gt;NLP处理音乐评论文章与报道；&lt;/li&gt;
&lt;li&gt;对音频使用卷积神经网络进行分析。    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些算法各有特点，音频分析显然可以用于解决冷启动问题，NLP处理音乐评论更是可以学得专业人士的领域知识，它们各自独立运行给出自己的结果，由于独立，算法数目可增可减，亦可各自独立迭代变化。    &lt;/p&gt;</summary>
    
    
    
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="算法" scheme="http://guerbai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>受限玻尔兹曼机的实现及其在推荐系统中的应用</title>
    <link href="http://guerbai.github.io/2019/03/07/restricted-boltzmann-machine/"/>
    <id>http://guerbai.github.io/2019/03/07/restricted-boltzmann-machine/</id>
    <published>2019-03-07T08:55:00.000Z</published>
    <updated>2021-11-06T08:53:26.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>受限玻尔兹曼机(restricted Boltzmann machine, RBM)是一种可通过输入数据集学习概率分布的随机生成神经网络，在降维、分类、协同过滤、特征学习和主题建模等领域中有着广泛应用。    </p></blockquote><p>在Netflix Prize后半程，有选手将RBM应用在该预测电影评分问题上并取得了不错的效果。后来Edwin Chen的文章<a href="http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/">《Introduction to Restricted Boltzmann Machines》</a>使用详细而易懂的方式(没什么数学公式与推导)描述了RBM的运作机理，并使用Python的numpy写了一个简易实现。    </p><p>这篇文章通过逐行阅读并运行<a href="https://github.com/echen/restricted-boltzmann-machines">Edwin Chen的开源代码</a>，观看其中用到的数据结构、值的变化来展现RBM的运作原理及实现技巧。</p><span id="more"></span><p>这里仍然把背景放到音乐这里来，使用六首歌曲来训练RBM，其中三首为Disco歌曲：ABBA的<em>Dancing Queen</em>，Bee Gees的<em>Stayin’ Alive</em>，新裤子的<em>别再问我什么是迪斯科</em>，另外三首是吉他英雄的solo：Dire Straits的<em>Sultans Of Swing</em>，Yngwie Malmsteen的<em>Black Star</em>和桶哥Buckethead的<em>Thorne Room</em>。    </p><p>作为一个神经网络，RBM有可见层和隐藏层两层，其中可见层每个节点对应一首歌曲，而隐藏层的每个节点我们则希望它对应于一种音乐类型，故对应上述歌曲的特点在说明中使隐藏层为两个节点。同时再加一个<em>bias unit</em>来控制太过热门的item对该模型造成的影响，此神经网络各节点的连接情况是这样的：</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/a4642c657403434cbf349d7bf4bd611a.jpg"></p><p>可见层的每个节点与所有隐藏层的节点相连，bias unit与两层所有的节点相连，每个连接对应一个weight，首先使用矩阵来表示可见层与隐藏层节点的所有weight，比如该矩阵的第一行的第一列的数据对应于可见层节点<em>Dancing Queen</em>与hidden unit1相连的weight，然后在此基础上，插入bias unit的weight，因为它与可见层、隐藏层皆相连，故此矩阵的行与列各加1。给两层节点之间的所有weight赋予一个范围内的随机值以初始化该矩阵，与bias unit相连的节点暂全置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_hidden = <span class="number">2</span></span><br><span class="line">num_visible = <span class="number">6</span></span><br><span class="line">np_rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">weights = np.asarray(np_rng.uniform(</span><br><span class="line">                low=-<span class="number">0.1</span> * np.sqrt(<span class="number">6.</span> / (num_hidden + num_visible)),</span><br><span class="line">                high=<span class="number">0.1</span> * np.sqrt(<span class="number">6.</span> / (num_hidden + num_visible)),</span><br><span class="line">                size=(num_visible, num_hidden)))</span><br><span class="line">weights</span><br></pre></td></tr></table></figure><pre><code>array([[-0.0534304 ,  0.02114986],       [-0.01078587,  0.04942556],       [ 0.04849323, -0.03938812],       [-0.03871753,  0.05228579],       [ 0.07935206,  0.06511344],       [-0.02462677,  0.00017236]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入bias unit.</span></span><br><span class="line">weights = np.insert(weights, <span class="number">0</span>, <span class="number">0</span>, axis=<span class="number">0</span>)</span><br><span class="line">weights = np.insert(weights, <span class="number">0</span>, <span class="number">0</span>, axis=<span class="number">1</span>)</span><br><span class="line">weights</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.        ,  0.        ,  0.        ],       [ 0.        , -0.0534304 ,  0.02114986],       [ 0.        , -0.01078587,  0.04942556],       [ 0.        ,  0.04849323, -0.03938812],       [ 0.        , -0.03871753,  0.05228579],       [ 0.        ,  0.07935206,  0.06511344],       [ 0.        , -0.02462677,  0.00017236]])</code></pre><p>接下来构造一些训练样本，一个样本是关于这六首歌的收听情况的list(按照上图从上到下的顺序对应list中的index)，填值1表示该user听过此歌，填值0表示该user未听过此歌。这里构造6个样本作为样本集合，同时考虑到weight矩阵增加了bias unit，为了后续线性代数运算的对应性，需要在样本集合形成的矩阵中再插入一列，值均置为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">num_examples = data.shape[<span class="number">0</span>]</span><br><span class="line">data = np.insert(data, <span class="number">0</span>, <span class="number">1</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">data</span><br></pre></td></tr></table></figure><pre><code>array([[1, 1, 1, 1, 0, 0, 0],       [1, 1, 0, 1, 0, 0, 0],       [1, 1, 1, 1, 0, 0, 0],       [1, 0, 0, 1, 1, 1, 0],       [1, 0, 0, 1, 1, 0, 0],       [1, 0, 0, 1, 1, 1, 0]])</code></pre><p>有了输入矩阵与weight矩阵，对于一个隐藏节点，计算它的值是1还是0，首先要将所有与它相连的节点的取值各自乘以相应的weight再做加和，比如对于靠上的隐藏节点，当输入第一个样本时，可见层的取值为<code>[1, 1, 1, 1, 0, 0, 0]</code>，相应的权重为<code>[0, -0.0534304, -0.01078587, 0.04849323, -0.03871753, 0.07935206, -0.02462677]</code>，两向量做点乘正好对应了上面的过程，注意两向量第一个值对应于bias unit，而bias unit的weight为0，对结果并未产生影响。</p><p>对于所有样本和所有的隐藏节点都是一样的处理，那么可将这么许多次点乘化为矩阵相乘，根据矩阵相乘的规则(行向量点乘列向量结果放在相应的位置)可以看出将data与weight矩阵相乘刚好表示对每个样本和每个隐藏节点将上述处理做了一次，会产生出一个新的形状为<code>(6*3)</code>的矩阵，第一列对应bias unit值全为0，第二列的第一个元素便对应了Dancing Queen在hidden unit1处生成的值。使用矩阵相乘，效率要比对样本和隐藏单元进行迭代快得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pos_hidden_activations = np.dot(data, weights)</span><br><span class="line"></span><br><span class="line">pos_hidden_activations</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.        , -0.01572304,  0.0311873 ],       [ 0.        , -0.00493717, -0.01823826],       [ 0.        , -0.01572304,  0.0311873 ],       [ 0.        ,  0.08912777,  0.07801112],       [ 0.        ,  0.00977571,  0.01289768],       [ 0.        ,  0.08912777,  0.07801112]])</code></pre><p>算出激活值后，众所周知，神经网络的节点往往包含一个激活函数，这里使用Sigmond函数，将上一步算出的激活值控制到0-1之间，来代表此节点被激活的可能性，当为某节点计算出的激活概率越接近1，则其被激活的可能性越大，这里利用numpy的广播功能，对上述生成的矩阵中的所有节点都施加一个Sigmond函数。然后将bias unit对应的那一列全改为1，这表示bias unit总是被激活的，具体原因见下文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line">pos_hidden_probs = logistic(pos_hidden_activations)</span><br><span class="line">pos_hidden_probs[:, <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">pos_hidden_probs</span><br></pre></td></tr></table></figure><pre><code>array([[1.        , 0.49606932, 0.50779619],       [1.        , 0.49876571, 0.49544056],       [1.        , 0.49606932, 0.50779619],       [1.        , 0.5222672 , 0.5194929 ],       [1.        , 0.50244391, 0.50322437],       [1.        , 0.5222672 , 0.5194929 ]])</code></pre><p>rand函数会随机生成一个处于0到1之间的数，将上述算出的节点激活概率与一个这样的随机数比较大小来决定是否激活此节点，这意味着即使此时某次训练中某隐藏结点的激活概率为0.99，也是有可能不被激活的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos_hidden_states = pos_hidden_probs &gt; np.random.rand(num_examples, num_hidden + <span class="number">1</span>)</span><br><span class="line">pos_hidden_states</span><br></pre></td></tr></table></figure><pre><code>array([[ True,  True,  True],       [ True, False, False],       [ True, False, False],       [ True,  True,  True],       [ True, False,  True],       [ True, False,  True]])</code></pre><p>这个矩阵的含义举例为其第一行第二列的值表示Dancing Queen是否激活了hidden unit1。</p><p>如上述进行过了一次所有样本对隐藏层激活情况的计算，可以得出Dancing Queen与hidden unit1同时亮起的相关性，记为$Positive(e_{ij})$，看上述矩阵<code>data</code>与<code>pos_hidden_probs</code>，第一个样本在Dancing Queen节点取值为1，对hidden unit1激活概率为0.49606932，将两者相乘得到一个值，对所有样本如此计算得到的值的加和即为这两个节点的相关性，这个过程同样可以使用矩阵相乘来表示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos_associations = np.dot(data.T, pos_hidden_probs)</span><br><span class="line">pos_associations</span><br></pre></td></tr></table></figure><pre><code>array([[6.        , 3.03788267, 3.05324311],       [3.        , 1.49090435, 1.51103295],       [2.        , 0.99213864, 1.01559239],       [6.        , 3.03788267, 3.05324311],       [3.        , 1.54697831, 1.54221017],       [2.        , 1.04453441, 1.03898579],       [0.        , 0.        , 0.        ]])</code></pre><p>如此，一次从可见层到隐藏层的计算便结束了。之后反过来，从隐藏层到可见层，将<code>pos_hidden_states</code>作为样本集合输入隐藏层，做一遍与上述过程完全相同的计算，同样可以计算出两相连节点之间的相关性，这次记为$Negative(e_{ij})$。由于是随机取的初始weight，Positive与Negative之间应该会有不小的差别，而RBM的优化目标便是通过多个epoch的训练，使其差别尽可能小。    </p><p>上述一正一反便算完成了一个epoch，根据式子$w _ { i j } = w _ { i j } + L * \left( \text {Positive} \left( e _ { i j } \right) - N e g a t i v e \left( e _ { i j } \right) \right)$算出新的weight值(其中L为学习速率需要炼金而得)，来开始下一个epoch的计算，如此会使得两者之间的差值越来越小，从而得到一个训练好的RBM模型。</p><p>比较巧妙的还是bias unit，可以看到上述有些可见节点与bias unit的关联值达到6，而在下一次循环中，又会对bias unit整个重新赋值，这个处理可以将那些热门的item对隐藏节点是否激活的影响引向这个bias unit，来稀释这种影响，尽量防止“the Beatles现象”的出现。同时，由于它与两层每个节点都相连，在从可见层到隐藏层的计算过程中，它其实是作为一个隐藏层节点来一同参与计算的，而在反向时，它又作为一个可见层节点来发挥作用，真是妙啊。</p><p>使用上述过程的完整版代码(见文末参考链接)，来看一下结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = RBM(num_visible = <span class="number">6</span>, num_hidden = <span class="number">2</span>)</span><br><span class="line">training_data = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">r.train(training_data, max_epochs = <span class="number">5000</span>)</span><br><span class="line"><span class="built_in">print</span>(r.weights[<span class="number">1</span>:, <span class="number">1</span>:])</span><br></pre></td></tr></table></figure><pre><code>[[-8.09650002  3.95552071] [-5.45512759  1.42845858] [ 1.74474585  4.06127352] [ 7.74906751 -3.54062571] [ 3.18686136 -7.33215302] [-2.46868951 -2.60826581]]</code></pre><p>从训练好的weight中可以看出，hidden unit1倾向于对应rock guitar hero的音乐，而hidden unit2则倾向于对应disco。</p><p>联系推荐系统，显然该模型可以对item做降维处理，与Word2vec一样，使用weight组成的向量表示即可，比如<em>Dancing Queen</em>可表示为<code>[-8.09650002, 3.95552071]</code>。<br>而要为user推荐item，则需要将其收听历史向量<code>[1, 1, 1, 0, 0, 0]</code>输入训练好的模型，激活一些隐藏节点，再将表示隐藏层节点被激活情况的向量反向输入模型，可为每个item得到一个被激活的概率，去掉用户已经听过的item，再对概率进行从大到小排序选取K个即可做出TopK推荐。该处理只有简单的向量计算非常迅速，可用于在线实时生成推荐结果。</p><p>对于显示反馈，比如Netflix Prize的情况，Ruslan Salakhutdinov等人对RBM提出了改进，可见层使用Softmax神经元来表示打分情况，对于没有被评分过的item则使用特殊的神经元表示，不与隐藏层相连避免无谓的计算；而条件RBM可以在处理显示反馈时将用户浏览过哪些物品这样的隐式反馈的影响同时考虑进去。这些改进都涉及到对本文计算过程与数学公式的改进，具体可以参考论文。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/echen/restricted-boltzmann-machines/blob/master/rbm.py">echen/restricted-boltzmann-machines</a><br><a href="http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/">Introduction to Restricted Boltzmann Machines</a><br><a href="http://www.cs.toronto.edu/~rsalakhu/papers/rbmcf.pdf">Restricted Boltzmann Machines for Collaborative Filtering</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;受限玻尔兹曼机(restricted Boltzmann machine, RBM)是一种可通过输入数据集学习概率分布的随机生成神经网络，在降维、分类、协同过滤、特征学习和主题建模等领域中有着广泛应用。    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Netflix Prize后半程，有选手将RBM应用在该预测电影评分问题上并取得了不错的效果。后来Edwin Chen的文章&lt;a href=&quot;http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/&quot;&gt;《Introduction to Restricted Boltzmann Machines》&lt;/a&gt;使用详细而易懂的方式(没什么数学公式与推导)描述了RBM的运作机理，并使用Python的numpy写了一个简易实现。    &lt;/p&gt;
&lt;p&gt;这篇文章通过逐行阅读并运行&lt;a href=&quot;https://github.com/echen/restricted-boltzmann-machines&quot;&gt;Edwin Chen的开源代码&lt;/a&gt;，观看其中用到的数据结构、值的变化来展现RBM的运作原理及实现技巧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="源码阅读" scheme="http://guerbai.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="算法" scheme="http://guerbai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Song2vec</title>
    <link href="http://guerbai.github.io/2019/03/01/song2vec/"/>
    <id>http://guerbai.github.io/2019/03/01/song2vec/</id>
    <published>2019-03-01T03:52:00.000Z</published>
    <updated>2021-11-06T08:53:26.440Z</updated>
    
    <content type="html"><![CDATA[<p>摇滚乐经过几十年的发展，风格流派众多，从blues，到brit invasion，之后是punk，disco，indie rock等等。发展历程大致是这样的：</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/b440dee638955292589841f11340f1f3.jpg" alt="history of rock"></p><span id="more"></span><p>摇滚乐的听众，总是能体会到发现宝藏的快乐，可能突然就会邂逅某支自己不曾接触过的歌曲、乐队、风格，感觉好听得不行，以前怎么从来不知道，接下来的一段时间便会沉浸于此，每天都在听该风格的主要乐队和专辑。用户收听音乐在一段时间内可能是有着某个“主题”的，这个主题可能是地理上的(俄罗斯的摇滚乐队)，可能是时间上的(2000年后优秀的专辑)，还可能是某流派、甚至是都被某影视作品用作BGM。之前很少听国内摇滚的笔者，在去年听了刺猬、P.K.14、重塑雕像的权利、新裤子、海朋森等一些国内乐队的很多作品后，才知道原来在老崔、窦唯、万青、老谢之外还有这么多优秀的国产摇滚乐。</p><p>这种“在某一时间会被用户放到一起听”的co-occurrence歌曲列表在音乐软件里的形态是playlist或radio，由editor或用户编辑生成，当然，还有”专辑“这个很强的联系，特别是像《The Dark Side of the Moon》这样的专辑。然而在<a href="https://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">前几篇文章</a>提到的内容中，最为核心的数据结构是用户物品关系矩阵，这里面并没有包含”一段时间“这个信息。这段时间可以称为session，在其他领域的实际应用中，这个session可能是一篇研究石墨烯的论文，可能是一个Airbnb用户某天在30分钟内寻找夏威夷租房信息的点击情况。把session内的co-occurrence关系考虑进去，可以为用户做出更符合其当下所处情境的推荐结果。</p><p>这篇文章使用Word2vec处理<a href="https://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-1K.html">Last.fm 1K数据集</a>，来完成这种纳入session信息的歌曲co-occurrence关系的建立。</p><h2 id="Word2vec与音乐推荐"><a href="#Word2vec与音乐推荐" class="headerlink" title="Word2vec与音乐推荐"></a>Word2vec与音乐推荐</h2><p>Word2vec最初被提出是为了在自然语言处理(NLP)中用一个低维稠密向量来表示一个word(该向量称为embedding)，并进一步根据embedding来研究词语之间的关系。它使用一个仅包含一层隐藏层的神经网络来训练被分成许多句子的数据，来学习词汇之间的co-occurrence关系，其中训练时分为CBOW(Continuous Bag-of-Words)与Skip-gram两种方式，这里简单说一下使用Skip-gram获取embedding的过程。</p><p>假设拿到了一些句子作为数据集，要为该神经网络生成训练样本，这里要定义一个窗口大小比如为2，则对”shine on you crazy diamond”这句话来讲，将窗口从左滑到右，按照下图方式生成一系列单词对儿，其中每个单词对儿即作为一个训练样本，单词对儿中的第一个单词为输入，第二个单词为label。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/c733cb646818b27288d38832fb40f334.jpg"></p><p>假设语料库中有10000个互不相同的word，首先将某个单词使用one-hot vector(10000维)来表示输入神经网络，输出同样为10000维的vector，每一维上的数字代表此位置为1所代表的one-hot vector所对应的word在输入word周围的可能性：</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/6d901ec288931487c179e94d26387572.jpg"></p><p>输入输出层的节点数为语料库word数，隐藏层的节点数则为表示每个单词的向量的维数。此模型每个输入层节点会与隐藏层的每个节点相连且都对应了一个权重，而对某输入节点来说，它与隐藏层相连的所有这些权重组成的向量即为该节点为1所代表的one-hot vector所对应的单词的embedding向量。</p><p>但该模型其实并不了解语义，它拥有的只是统计学知识，那么既然可以根据one-hot vector来标识一个word，当然可以用这种形式来标识一首歌曲，一支乐队，一件商品，一间出租屋等等任何可以被推荐的东西，再把这些数据喂给模型，同样的训练过程，便可以获取到各种物品embedding，然后研究它们之间的关系，此谓Item2vec，万物皆可embedding。</p><p>故Word2vec与音乐推荐的关系就是，把一个歌单或者某个user在一个下午连续收听的歌曲当作一句话(session)，把每首歌当作一个独立的word，然后把这样的数据交给此模型去训练即可获取每首歌的embedding向量，这里从歌单到一句话的抽象，即实现了上文中提到的考虑进去“一段时间”这个点。</p><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>该数据集包含了1K用户对960K歌曲的收听情况，文件1915万行，2.4G，每行记录了某用户在某时间播放了某歌曲的信息。依然是用pandas把数据加载进来，这次需要timestamp的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> arrow</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix, diags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&#x27;~/music-recommend/dataset/lastfm-dataset-1K/userid-timestamp-artid-artname-traid-traname.tsv&#x27;</span></span><br><span class="line">df = pd.read_csv(file_path, </span><br><span class="line">            sep = <span class="string">&#x27;\t&#x27;</span>,</span><br><span class="line">            header = <span class="literal">None</span>,                   </span><br><span class="line">            names = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>, <span class="string">&#x27;artist_id&#x27;</span>, <span class="string">&#x27;artist_name&#x27;</span>, <span class="string">&#x27;track_id&#x27;</span>, <span class="string">&#x27;track_name&#x27;</span>],</span><br><span class="line">            usecols = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>, <span class="string">&#x27;track_id&#x27;</span>, <span class="string">&#x27;artist_name&#x27;</span>, <span class="string">&#x27;track_name&#x27;</span>],</span><br><span class="line">           )</span><br><span class="line">df = df.dropna()</span><br><span class="line"><span class="built_in">print</span> (df.info())</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;Int64Index: 16936136 entries, 10 to 19098861Data columns (total 5 columns):user_id        objecttimestamp      objectartist_name    objecttrack_id       objecttrack_name     objectdtypes: object(5)memory usage: 775.3+ MB</code></pre><p>接下来做一些辅助的数据，为每个user、每首track都生成一个用于标识自己的index，建立从index到id，从id到index的双向查询dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;user_id&#x27;</span>] = df[<span class="string">&#x27;user_id&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;track_id&#x27;</span>] = df[<span class="string">&#x27;track_id&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_index_to_user_id_dict = df[<span class="string">&#x27;user_id&#x27;</span>].cat.categories <span class="comment"># use it like a dict.</span></span><br><span class="line">user_id_to_user_index_dict = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;user_id&#x27;</span>].cat.categories):</span><br><span class="line">    user_id_to_user_index_dict[i] = index</span><br><span class="line">    </span><br><span class="line">track_index_to_track_id_dict = df[<span class="string">&#x27;track_id&#x27;</span>].cat.categories <span class="comment"># use it like a dict.</span></span><br><span class="line">track_id_to_track_index_dict = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;track_id&#x27;</span>].cat.categories):</span><br><span class="line">    track_id_to_track_index_dict[i] = index</span><br><span class="line">    </span><br><span class="line">song_info_df = df[[<span class="string">&#x27;artist_name&#x27;</span>, <span class="string">&#x27;track_name&#x27;</span>, <span class="string">&#x27;track_id&#x27;</span>]].drop_duplicates()</span><br></pre></td></tr></table></figure><p>考虑到专辑翻唱、同名、专辑重新发行等情况，需要用track_id来作为一首歌的唯一标识，而当需要通过<code>artist_name</code>，<code>track_name</code>来定位到一首歌时，这里写了一个函数，采取的策略是找到被播放最多的那一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hot_track_id_by_artist_name_and_track_name</span>(<span class="params">artist_name, track_name</span>):</span></span><br><span class="line">    track = song_info_df[(song_info_df[<span class="string">&#x27;artist_name&#x27;</span>] == artist_name) &amp; (song_info_df[<span class="string">&#x27;track_name&#x27;</span>] == track_name)]</span><br><span class="line">    max_listened = <span class="number">0</span></span><br><span class="line">    hotest_row_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(track.shape[<span class="number">0</span>]):</span><br><span class="line">        row = track.iloc[i]</span><br><span class="line">        track_id = row[<span class="string">&#x27;track_id&#x27;</span>]</span><br><span class="line">        listened_count = df[df[<span class="string">&#x27;track_id&#x27;</span>] == track_id].shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> listened_count &gt; max_listened:</span><br><span class="line">            max_listened = listened_count</span><br><span class="line">            hotest_row_index = i</span><br><span class="line">    <span class="keyword">return</span> track.iloc[hotest_row_index][<span class="string">&#x27;track_id&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;wish you were here tracks:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (song_info_df[(song_info_df[<span class="string">&#x27;artist_name&#x27;</span>] == <span class="string">&#x27;Pink Floyd&#x27;</span>) &amp; (song_info_df[<span class="string">&#x27;track_name&#x27;</span>] == <span class="string">&#x27;Wish You Were Here&#x27;</span>)][[<span class="string">&#x27;track_id&#x27;</span>]])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;--------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;hotest one:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (get_hot_track_id_by_artist_name_and_track_name(<span class="string">&#x27;Pink Floyd&#x27;</span>, <span class="string">&#x27;Wish You Were Here&#x27;</span>))</span><br></pre></td></tr></table></figure><pre><code>wish you were here tracks:                                      track_id60969     feecff58-8ee2-4a7f-ac23-dc8ce79252864401932   f479e316-56b4-4221-acd9-eed1a071186117332322  2210ba38-79af-4881-97ae-4ce8f32322c3--------hotest one:feecff58-8ee2-4a7f-ac23-dc8ce7925286</code></pre><h2 id="生成sentences文件"><a href="#生成sentences文件" class="headerlink" title="生成sentences文件"></a>生成sentences文件</h2><p>加载过数据后接下来要生成在科普环节提到的由歌名歌单生成句子，由于懒，没有去爬云音乐的歌单数据，这里粗暴地将每个用户每一天收听的所有歌曲作为一个session，使用上文生成的<code>track_index</code>来标识各歌曲，将生成的sentences写到磁盘上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_sentence_file</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sentences.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> sentences:</span><br><span class="line">        <span class="keyword">for</span> user_index <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(user_index_to_user_id_dict))):</span><br><span class="line">            user_id = user_index_to_user_id_dict[user_index]</span><br><span class="line">            user_df = df[df[<span class="string">&#x27;user_id&#x27;</span>] == user_id].sort_values(<span class="string">&#x27;timestamp&#x27;</span>)</span><br><span class="line">            session = <span class="built_in">list</span>()</span><br><span class="line">            last_time = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> index, row <span class="keyword">in</span> user_df.iterrows():</span><br><span class="line">                this_time = row[<span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">                track_index = track_id_to_track_index_dict[row[<span class="string">&#x27;track_id&#x27;</span>]]</span><br><span class="line">                <span class="keyword">if</span> arrow.get(this_time).date() != arrow.get(last_time).date() <span class="keyword">and</span> last_time != <span class="literal">None</span>:</span><br><span class="line">                    sentences.write(<span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(_<span class="built_in">id</span>) <span class="keyword">for</span> _<span class="built_in">id</span> <span class="keyword">in</span> session]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    session = <span class="built_in">list</span>()</span><br><span class="line">                session.append(track_index)</span><br><span class="line">                last_time = this_time</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generate_sentence_file(df)</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 992/992 [1:22:23&lt;00:00,  5.62s/it]</code></pre><p>这个过程比较慢，在mac跑下来要快一个半小时。这里可以使用Spark来生成sentences.txt，若是在生产环境，可以利用大量机器资源，在单机上亦可以享受其将任务拆分成map、reduce来并行处理的便利，以如下Spark代码来生成Sentences.txt在mac上只需要10分钟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyspark</span><br><span class="line"><span class="keyword">import</span> arrow</span><br><span class="line"></span><br><span class="line">sc = pyspark.SparkContext(appName=<span class="string">&quot;generate-song-sentences&quot;</span>)</span><br><span class="line">lines = sc.textFile(file_path)</span><br><span class="line">lines = lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> l: l.split(<span class="string">&quot;\t&quot;</span>)) <span class="comment"># 按\t分隔为list.</span></span><br><span class="line">lines = lines.<span class="built_in">filter</span>(<span class="keyword">lambda</span> l: <span class="built_in">len</span>([item <span class="keyword">for</span> item <span class="keyword">in</span> l <span class="keyword">if</span> <span class="keyword">not</span> item]) == <span class="number">0</span>) <span class="comment"># 去掉数据不全的行.</span></span><br><span class="line">lines = lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> line: ((line[<span class="number">0</span>], arrow.get(line[<span class="number">1</span>]).date()), <span class="built_in">str</span>(track_id_to_track_index_dict.get(line[<span class="number">4</span>], <span class="string">&#x27;&#x27;</span>)))) <span class="comment"># 以(user_id, date)为key，track_id为value的二元组.</span></span><br><span class="line">lines = lines.reduceByKey(<span class="keyword">lambda</span> a, b: a + <span class="string">&#x27; &#x27;</span> + b) <span class="comment"># reduce，将track_id拼为sentence.</span></span><br><span class="line">lines = lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> line: line[<span class="number">1</span>]) <span class="comment"># 输出不再关心key.</span></span><br><span class="line">lines.repartition(<span class="number">1</span>).saveAsTextFile(<span class="string">&quot;./spark-generated-song-sentences&quot;</span>) <span class="comment"># 使Spark只写一份txt文件.</span></span><br></pre></td></tr></table></figure><p>生成后的文件长这个样子：<br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/2bb7a1295741acbdfc763f353f93576c.jpg"></p><h2 id="训练模型生成embedding"><a href="#训练模型生成embedding" class="headerlink" title="训练模型生成embedding"></a>训练模型生成embedding</h2><p>有很多种方式可以获取、实现Word2vec的代码，可以用Tensorflow、Keras基于神经网络写一个，亦可以使用Google放到Google Code上的Word2vec实现，也可以在Github上找到<a href="https://github.com/RaRe-Technologies/gensim">gensim</a>这个优秀的库使用其已经封装好的实现。</p><p>下列代码使用<code>smart_open</code>来逐行读取之前生成的sentences.txt文件，对内存很是友好。这里使用50维的向量来代表一首歌曲，将收听总次数不到20次的冷门歌曲筛选出去，设窗口大小为5。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> smart_open <span class="keyword">import</span> smart_open</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig()</span><br><span class="line">logging.getLogger().setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LastfmSentences</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_location</span>):</span></span><br><span class="line">        self.file_location = file_location</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> smart_open(self.file_location, <span class="string">&#x27;r&#x27;</span>):</span><br><span class="line">            <span class="keyword">yield</span> line.split()</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">lastfm_sentences = LastfmSentences(<span class="string">&#x27;./sentences.txt&#x27;</span>)</span><br><span class="line">model = Word2Vec(lastfm_sentences, size=<span class="number">50</span>, min_count=<span class="number">20</span>, window=<span class="number">10</span>, hs=<span class="number">0</span>, negative=<span class="number">20</span>, workers=<span class="number">4</span>, sg=<span class="number">1</span>, sample=<span class="number">1e-5</span>)</span><br></pre></td></tr></table></figure><p>假如训练的数据集为歌单，一个歌单为一个句子，由于出现在同一个歌单内代表了其中歌曲的某种共性，那么会希望将所有item两两之间的关系都考虑进去，故window size的取值可以取<code>(所有歌单长度最大值-1)/2</code>，会取得更好的效果。这里由于是以用户和天做分割，暂且拍脑袋拍出一个10。<br>sample用于控制对热门词汇的采样比例，降低太过热门的词汇对整个模型的影响，比如Radiohead的creep，这里面还有个计算公式不再细说。<br>sg取0、1分别表示使用CBOW与Skip-gram算法，而hs取0、1分别表示使用hierarchical softmax与negative sampling。</p><p>关于negative sampling值得多说两句，在神经网络的训练过程中需要根据梯度下降去调整节点之间的weight，可由于要调的weight数量巨大，在这个例子里为<code>2*50*960000</code>，效率会很低下，处理方法使用负采样，仅选取此训练样本的label为正例，其他随机选取5到20个(经验数值)单词为反例，仅调整与这几个word对应的weight，会使效率获取明显提升，并且效果也很良好。随机选取的反例的规则亦与单词出现频率有关，出现频次越多的单词，越有可能会被选中为反例。</p><h2 id="利用embedding"><a href="#利用embedding" class="headerlink" title="利用embedding"></a>利用embedding</h2><p>现在已经用大量数据为各track生成了与自己对应的低维向量，比如Wish You Were Here这首歌，这个embedding可以作为该歌曲的标识用于其他机器学习任务比如learn to rank：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.wv[<span class="built_in">str</span>(track_id_to_track_index_dict[</span><br><span class="line">    get_hot_track_id_by_artist_name_and_track_name(</span><br><span class="line">        <span class="string">&#x27;Pink Floyd&#x27;</span>, <span class="string">&#x27;Wish You Were Here&#x27;</span>)])]</span><br></pre></td></tr></table></figure><pre><code>array([-0.39100856,  0.28636533,  0.11853614, -0.41582254,  0.09754885,        0.59501815, -0.07997745, -0.28060785, -0.0384276 , -0.84899545,        0.03777567, -0.00727402,  0.6960302 ,  0.44756493, -0.13245133,       -0.38473454, -0.07809031,  0.34377965, -0.19210865, -0.33457756,       -0.36364776, -0.06028108,  0.17379969,  0.46617758, -0.04116876,        0.07322323,  0.11769405,  0.42464802,  0.25167897, -0.35790011,        0.01991512, -0.10950506,  0.26131895, -0.76148427,  0.48405901,        0.61935854, -0.59583783,  0.28353232, -0.14503367,  0.3232002 ,        1.00872386, -0.10348291, -0.0485305 ,  0.21677236, -1.33224928,        0.57913464, -0.06729769, -0.32185984, -0.02978219, -0.43034038], dtype=float32)</code></pre><p>这些embedding vector之间的相似度可以表示两首歌出现在同一session内的可能性大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shine_on_part_1 = <span class="built_in">str</span>(track_id_to_track_index_dict[</span><br><span class="line">    get_hot_track_id_by_artist_name_and_track_name(<span class="string">&#x27;Pink Floyd&#x27;</span>, <span class="string">&#x27;Shine On You Crazy Diamond (Parts I-V)&#x27;</span>)])</span><br><span class="line">shine_on_part_2 = <span class="built_in">str</span>(track_id_to_track_index_dict[</span><br><span class="line">    get_hot_track_id_by_artist_name_and_track_name(<span class="string">&#x27;Pink Floyd&#x27;</span>, <span class="string">&#x27;Shine On You Crazy Diamond (Parts Vi-Ix)&#x27;</span>)])</span><br><span class="line">good_times = <span class="built_in">str</span>(track_id_to_track_index_dict[</span><br><span class="line">    get_hot_track_id_by_artist_name_and_track_name(<span class="string">&#x27;Chic&#x27;</span>, <span class="string">&#x27;Good Times&#x27;</span>)])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;similarity between shine on part 1, 2:&#x27;</span>, model.wv.similarity(shine_on_part_1, shine_on_part_2))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;similarity between shine on part 1, good times:&#x27;</span>, model.wv.similarity(shine_on_part_1, good_times))</span><br></pre></td></tr></table></figure><pre><code>similarity between shine on part 1, 2: 0.927217similarity between shine on part 1, good times: 0.425195</code></pre><p>稍微看下源码便会发现上述similarity函数，gensim也是使用余弦相似度来计算的，同样可以根据该相似度，来生成一些推荐列表，当然不可能去遍历，gensim内部也是使用上篇文章提到的Annoy来构建索引来快速寻找近邻的。为了使用方便写了如下两个包装函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend_with_playlist</span>(<span class="params">playlist, topn=<span class="number">25</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(playlist, <span class="built_in">list</span>):</span><br><span class="line">        playlist = [playlist]</span><br><span class="line">    playlist_indexes = [<span class="built_in">str</span>(track_id_to_track_index_dict[track_id]) <span class="keyword">for</span> track_id <span class="keyword">in</span> playlist]</span><br><span class="line">    similar_song_indexes = model.wv.most_similar(positive=playlist_indexes, topn=topn)</span><br><span class="line">    <span class="keyword">return</span> [track_index_to_track_id_dict[<span class="built_in">int</span>(track[<span class="number">0</span>])] <span class="keyword">for</span> track <span class="keyword">in</span> similar_song_indexes]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_track_info</span>(<span class="params">track_ids</span>):</span></span><br><span class="line">    track_info = &#123;</span><br><span class="line">        <span class="string">&#x27;track_name&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;artist_name&#x27;</span>: [],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> track_id <span class="keyword">in</span> track_ids:</span><br><span class="line">        track = song_info_df[song_info_df[<span class="string">&#x27;track_id&#x27;</span>] == track_id].iloc[<span class="number">0</span>]</span><br><span class="line">        track_info[<span class="string">&#x27;track_name&#x27;</span>].append(track[<span class="string">&#x27;track_name&#x27;</span>])</span><br><span class="line">        track_info[<span class="string">&#x27;artist_name&#x27;</span>].append(track[<span class="string">&#x27;artist_name&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span> (pd.DataFrame(track_info))</span><br></pre></td></tr></table></figure><p>接下来假装自己在听后朋，提供几首歌曲，看看模型会给我们推荐什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post punk.</span></span><br><span class="line"></span><br><span class="line">guerbai_playlist = [</span><br><span class="line">    (<span class="string">&#x27;Joy Division&#x27;</span>, <span class="string">&#x27;Disorder&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Echo &amp; The Bunnymen&#x27;</span>, <span class="string">&#x27;The Killing Moon&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;The Names&#x27;</span>, <span class="string">&#x27;Discovery&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;The Cure&#x27;</span>, <span class="string">&#x27;Lullaby&#x27;</span>),</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">display_track_info(recommend_with_playlist([</span><br><span class="line">    get_hot_track_id_by_artist_name_and_track_name(track[<span class="number">0</span>], track[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">for</span> track <span class="keyword">in</span> guerbai_playlist], <span class="number">20</span>))</span><br></pre></td></tr></table></figure><pre><code>                   track_name          artist_name0               Miss The Girl        The Creatures1      Splintered In Her Head             The Cure2    Return Of The Roughnecks       The Chameleons3                P.S. Goodbye       The Chameleons4                Chelsea Girl         Simple Minds5    23 Minutes Over Brussels              Suicide6          Not Even Sometimes            The Prids7                     Windows  A Flock Of Seagulls8     Ride The Friendly Skies       Lightning Bolt9                Inmost Light      Double Leopards10              Thin Radiance             Sunroof!11        You As The Colorant            The Prids12    Love Will Tear Us Apart         Boy Division13                  Slip Away             Ultravox14                Street Dude           Black Dice15              Touch Defiles        Death In June16     All My Colours (Zimbo)  Echo &amp; The Bunnymen17                Summernight             The Cold18         Pornography (Live)             The Cure19  Me, I Disconnect From You           Gary Numan</code></pre><p>好多乐队都没见过，wiki一下发现果然大都是后朋与新浪潮乐队的歌曲，搞笑的是Love Will Tear Us Apart竟然成了Boy Division的了，这数据集有毒。。    </p><p>过了半年又沉浸在前卫摇滚的长篇里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># long progressive</span></span><br><span class="line"></span><br><span class="line">guerbai_playlist = [</span><br><span class="line">    (<span class="string">&#x27;Rush&#x27;</span>, <span class="string">&#x27;2112: Ii. The Temples Of Syrinx&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;Roundabout&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Emerson, Lake &amp; Palmer&#x27;</span>, <span class="string">&#x27;Take A Pebble&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jethro Tull&#x27;</span>, <span class="string">&#x27;Aqualung&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">display_track_info(recommend_with_playlist([</span><br><span class="line">    get_hot_track_id_by_artist_name_and_track_name(track[<span class="number">0</span>], track[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">for</span> track <span class="keyword">in</span> guerbai_playlist]))</span><br></pre></td></tr></table></figure><pre><code>                            track_name             artist_name0                            Nutrocker  Emerson, Lake &amp; Palmer1                  Brain Salad Surgery  Emerson, Lake &amp; Palmer2                           Black Moon  Emerson, Lake &amp; Palmer3                            Parallels                     Yes4                      Working All Day            Gentle Giant5                            Musicatto                  Kansas6                    Farewell To Kings                    Rush7                    My Sunday Feeling             Jethro Tull8             Thick As A Brick, Part 1             Jethro Tull9                South Side Of The Sky                     Yes10                  Living In The Past             Jethro Tull11  The Fish (Schindleria Praematurus)                     Yes12                    Starship Trooper                     Yes13                                Tank  Emerson, Lake &amp; Palmer14              I Think I&#39;M Going Bald                    Rush15                          Here Again                    Rush16                           Lucky Man  Emerson, Lake &amp; Palmer17                      Cinderella Man                    Rush18                        Stick It Out                    Rush19                   The Speed Of Love                    Rush20                   New State Of Mind                     Yes21         Karn Evil 9: 2Nd Impression  Emerson, Lake &amp; Palmer22                           A Venture                     Yes23                          Cygnus X-1                    Rush24                         Sweet Dream             Jethro Tull</code></pre><p>人是会变的，今天她喜欢听后朋，明天可能喜欢别的，但既然我们有数学与集体智慧，问题并不大。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://towardsdatascience.com/using-word2vec-for-music-recommendations-bb9649ac2484">Using Word2vec for Music Recommendations</a><br><a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/">Word2Vec Tutorial - The Skip-Gram Model</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摇滚乐经过几十年的发展，风格流派众多，从blues，到brit invasion，之后是punk，disco，indie rock等等。发展历程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/guerbai/scene/main/blog/b440dee638955292589841f11340f1f3.jpg&quot; alt=&quot;history of rock&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="摇滚乐" scheme="http://guerbai.github.io/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="算法" scheme="http://guerbai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>为什么与Yes乐队最相似的歌手是Coda(小田和奏)？</title>
    <link href="http://guerbai.github.io/2019/02/24/matrix-factorization/"/>
    <id>http://guerbai.github.io/2019/02/24/matrix-factorization/</id>
    <published>2019-02-24T15:36:00.000Z</published>
    <updated>2021-11-06T08:53:26.436Z</updated>
    
    <content type="html"><![CDATA[<p>在网易云音乐中，点入某歌手主页时会有一栏为相似歌手：<br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/aefe5c43cb674b203c42b9ae07907363.jpg"></p><p>Yes是1968年成立的著名前卫摇滚乐队，云音乐中与其相似的列表中有Rush，而后者则是来自加拿大的一支异常出色的前卫摇滚乐队，这对于一个喜爱前卫摇滚的听众来说，当然是一个很不错的推荐。然而，Yes的推荐列表中的第一位是Coda(小田和奏)，此君是何许人也，此君并不像Rush、Yes一样是几十年前便成立并在摇滚史上留下浓墨重彩的前卫摇滚音乐人，那云音乐又为何会把此君放在Yes相似列表的第一位呢？ </p><span id="more"></span><p>稍微看过Yes歌曲的评论便会知道个中原因，在当今中国大地上Yes这支乐队的歌曲得到曝光，很大程度上是靠《JOJO的奇妙冒险》这部日本动漫中使用了该乐队的音乐，而云音乐里的评论亦均是来自此动漫观光团，而同时这位Coda(小田和奏)的热门歌曲即是该动漫的片头片尾曲，如此便为他们之间的“相似”找到了原因，该观光团必然是既听了Yes的《Roundabout》，又听了此君的作品，因为该动漫的火爆，使得云音乐中那些听过Yes而不看动漫的前卫听众相比因为看该动漫而听Yes的观光团反而成了少数，这直接越过了音乐内容本质，改变了相似列表的值。</p><p>看到了上面的例子，很显然这种音乐人之间的相似关联很难仅靠了解音乐的编辑来给出，一方面是音乐人数量巨大，另一个是可能产生关联的维度太多，这便需要寻求集体智慧。</p><p>这篇文章使用矩阵分解处理<a href="https://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-360K.html">Last.fm 360K数据集</a>，利用海量用户数据来完成音乐人之间相似关系的建立。</p><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>Last.fm 360K数据集包含了36万users对30万artists的收听情况，文件大小1.6G，共17559530行记录，而在现实的工业应用中，世界著名的音乐软件<a href="https://www.spotify.com/hk-en/">Spotify</a>在2014年即拥有2400万users与2000万songs。    </p><p>这种数量级，已经不能像之前介绍<code>item-based CF</code>时直接用numpy生成一个这样shape的用户物品关系矩阵了，稍作计算<code>17559530/(300000*360000)=0.01%</code>后发现此数据集非常稀疏，仅0.01%的位置上有值，毕竟一个user不可能听到很多的artists。scipy提供了几种处理这种稀疏矩阵的方法，可以使矩阵中那些有真实值的位置才占内存，这里使用<code>csr_matrix</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix, diags</span><br><span class="line"><span class="keyword">from</span> scipy.sparse.linalg <span class="keyword">import</span> spsolve</span><br><span class="line"></span><br><span class="line">df = pd.read_table(<span class="string">&quot;~/Desktop/lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv&quot;</span>, </span><br><span class="line">                         usecols=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], </span><br><span class="line">                         names=[<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;artist&#x27;</span>, <span class="string">&#x27;plays&#x27;</span>],</span><br><span class="line">                         na_filter=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做user_id与artist_name到user_item_matrix index的映射.</span></span><br><span class="line">df[<span class="string">&#x27;user&#x27;</span>] = df[<span class="string">&#x27;user&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;artist&#x27;</span>] = df[<span class="string">&#x27;artist&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据上一步生成的id到index的映射，及df的id的关系，生成csr_matrix.</span></span><br><span class="line">plays = csr_matrix((df[<span class="string">&#x27;plays&#x27;</span>].astype(<span class="built_in">float</span>), </span><br><span class="line">                   (df[<span class="string">&#x27;user&#x27;</span>].cat.codes, </span><br><span class="line">                    df[<span class="string">&#x27;artist&#x27;</span>].cat.codes)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;user count &#x27;</span>, plays.shape[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;artist count &#x27;</span>, plays.shape[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;plays matrix memory usage: %d MB.&#x27;</span> % (plays.data.nbytes/<span class="number">1024</span>/<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_row_index_by_user</span>(<span class="params">user</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;user&#x27;</span>].cat.categories):</span><br><span class="line">        <span class="keyword">if</span> i == user:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_col_index_by_artist</span>(<span class="params">artist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;artist&#x27;</span>].cat.categories):</span><br><span class="line">        <span class="keyword">if</span> i == artist:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sparse_matrix_item</span>(<span class="params">i, j</span>):</span></span><br><span class="line">    <span class="keyword">return</span> plays.getrow(i).getcol(j).data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>user count  358868artist count  292365plays matrix memory usage: 133 MB.</code></pre><p>加载数据后得到稀疏矩阵<code>plays</code>，里面填的值是某user收听某artist的次数，同时写了几个辅助函数，可以通过<code>user_id</code>，<code>artist_name</code>得到在矩阵中相应的值。这里做一个抽样检查，head一下文件第5行会看到’00000c289a1829a808ac09c00daf10bc3c4e223b’这位用户收听’red hot chili peppers’次数为691次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user1_index = get_row_index_by_user(<span class="string">&#x27;00000c289a1829a808ac09c00daf10bc3c4e223b&#x27;</span>)</span><br><span class="line">artist1_index = get_col_index_by_artist(<span class="string">&#x27;red hot chili peppers&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;00000c289a1829a808ac09c00daf10bc3c4e223b listened red hot chili peppers count: &#x27;</span>, get_sparse_matrix_item(user1_index, artist1_index))</span><br></pre></td></tr></table></figure><pre><code>00000c289a1829a808ac09c00daf10bc3c4e223b listened red hot chili peppers count:  691.0</code></pre><h2 id="矩阵分解理论基础"><a href="#矩阵分解理论基础" class="headerlink" title="矩阵分解理论基础"></a>矩阵分解理论基础</h2><p>当然使用<a href="https://guerbai.github.io/2019/02/16/intro-to-collaborative-filtering/">基于领域的协同过滤</a>也可以做这个事情，但已经不再合适，首先向量维度越高相互之间计算相似度越慢，更重要的是，决定用户是否喜欢听某歌手的原因可能是多方面的，但绝不是要到30万这个数量级这么多的方面来决定的，这里面并不是一个线性的关系。</p><p>矩阵分解是对上述用户物品关系矩阵的降维打击，为user和item各生成一个低维的隐因子，来表达各自的特征：<br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/29021bda37b62ee589745eb5544cac2d.jpg" alt="matrix factorization"></p><p>将原矩阵分解成两个矩阵，两矩阵的乘积尽可能与原矩阵相等，越接近越好。对于电影评分这样的显示反馈来讲，损失函数为：<br>$$<br>\min _ { x _ { * } , y _ {*} , } \sum _ { u , i }  \left( p _ { u i } - x _ { u } ^ { T } y _ { i } \right) ^ { 2 } + \lambda \left( \sum _ { u } \left| x _ { u } \right| ^ { 2 } + \sum _ { i } \left| y _ { i } \right| ^ { 2 } \right)<br>$$</p><p>而对于听音乐这样的隐示反馈，损失函数需要添加一个置信度：<br>$$<br>\min _ { x _ { * } , y _ {*} , } \sum _ { u , i } c _ { u i } \left( p _ { u i } - x _ { u } ^ { T } y _ { i } \right) ^ { 2 } + \lambda \left( \sum _ { u } \left| x _ { u } \right| ^ { 2 } + \sum _ { i } \left| y _ { i } \right| ^ { 2 } \right)<br>$$</p><p>其中$c_{ui}$即为置信度，与收听次数有关：<br>$$<br>c _ { u i } = 1 + \alpha r _ { u i }<br>$$</p><p>$r_{ui}$为收听次数，$\alpha$为超参数，经验默认值40，$\lambda$为正则化系数，用来防止过拟合。</p><p>对上述损失函数的优化方式为ALS的变体Weighted-ALS(加权最小交替二乘法)，将item固定，对损失函数求导可得用户向量为：</p><p>$$<br>x _ { u } = \left( Y ^ { T } C ^ { u } Y + \lambda I \right) ^ { - 1 } Y ^ { T } C ^ { u } p ( u )<br>$$</p><p>上式中$Y$为此次计算中被固定的矩阵，$C^{u}$为以用户u的置信度向量生成的对角矩阵，$p(u)$是用户u的收听向量，在用户听过的artist的位置填入1，其他位置填0。</p><h2 id="矩阵分解代码"><a href="#矩阵分解代码" class="headerlink" title="矩阵分解代码"></a>矩阵分解代码</h2><p>有了上面的公式，很容易使用numpy表示这一计算过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weighted_alternating_least_squares</span>(<span class="params">plays, factors, alpha=<span class="number">40</span>, regularization=<span class="number">0.1</span>, iterations=<span class="number">20</span></span>):</span></span><br><span class="line">    Cui = (plays * alpha).astype(<span class="string">&#x27;double&#x27;</span>) <span class="comment"># 这里为了保持矩阵的稀疏，暂不加1，在后面的过程中补上；</span></span><br><span class="line">    users, items = Cui.shape</span><br><span class="line"></span><br><span class="line">    X = np.random.rand(users, factors) * <span class="number">0.01</span></span><br><span class="line">    Y = np.random.rand(items, factors) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    Ciu = Cui.T.tocsr()</span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        least_squares(Cui, X, Y, regularization)</span><br><span class="line">        least_squares(Ciu, Y, X, regularization)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">least_squares</span>(<span class="params">Cui, X, Y, regularization</span>):</span></span><br><span class="line">    users, factors = X.shape</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(users):</span><br><span class="line">        conf = Cui[u,:].toarray() ；</span><br><span class="line">        pref = conf.copy()</span><br><span class="line">        conf = conf + <span class="number">1</span> <span class="comment"># 此时仅取出一行，补上1</span></span><br><span class="line">        pref[pref != <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        Cu = diags(conf, [<span class="number">0</span>])</span><br><span class="line">        A = Y.T.dot(Cu).dot(Y) + regularization * np.eye(factors)</span><br><span class="line">        b = Y.T.dot(Cu).dot(pref.T)</span><br><span class="line">        X[u] = spsolve(A, b) </span><br></pre></td></tr></table></figure><p>依然是数据量的问题，上述代码基本是没法用的。大矩阵各种点乘，空间和时间消费都难以承受。优化方法是利用数学，显然$Y ^ { T } C ^ { u } Y$等于$Y ^ { T } Y + Y ^ { T } \left( C ^ { u } - I \right) Y$，由于当用户u没有收听artist i时，$c_{ui}$为1，使得$\left( C ^ { u } - I \right)$非常稀疏，同时p(u)亦非常稀疏，计算时将矩阵点乘拆开，仅取出有值的部分循环相加即可，如此可极大程度提升计算速度并降低对内存的需求。</p><p><a href="https://github.com/benfred/implicit">implicit</a>的作者在blog中实现了这一过程，里面全是线性代数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nonzeros</span>(<span class="params">m, row</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(m.indptr[row], m.indptr[row+<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">yield</span> m.indices[index], m.data[index]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">least_squares</span>(<span class="params">Cui, X, Y, regularization</span>):</span></span><br><span class="line">    users, factors = X.shape</span><br><span class="line">    YtY = Y.T.dot(Y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(users):</span><br><span class="line">        <span class="keyword">if</span> u % <span class="number">10000</span> == <span class="number">0</span> <span class="keyword">and</span> u &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> (u)</span><br><span class="line">        <span class="comment"># accumulate YtCuY + regularization * I in A</span></span><br><span class="line">        A = YtY + regularization * np.eye(factors)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># accumulate YtCuPu in b</span></span><br><span class="line">        b = np.zeros(factors)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, confidence <span class="keyword">in</span> nonzeros(Cui, u):</span><br><span class="line">            factor = Y[i]</span><br><span class="line">            A += (confidence - <span class="number">1</span>) * np.outer(factor, factor)</span><br><span class="line">            b += confidence * factor</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Xu = (YtCuY + regularization * I)^-1 (YtCuPu)</span></span><br><span class="line">        X[u] = np.linalg.solve(A, b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_factors, artist_factors = weighted_alternating_least_squares(plays, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>尽管如此，这个分解依然在mac上跑了三个多小时，当然还有更快的方法，implicit库中，作者加了C++代码，可以多线程，并且可以使用GPU加速，10几分钟就可以跑下来360K数据集。    </p><p>对于置信度的计算方法，论文里还给了另一个效果更好的公式：$c _ { u i } = 1 + \alpha \log \left( 1 + r _ { u i } / \epsilon \right)$，本文提到的第一个置信度计算方式无疑会导致the beatles问题，the beatles太火了大家都听过，导致会出现一些莫名其秒的相似结果，implicit作者推荐使用bm25算法来计算此weight，可以消除这种影响，使结果趋于更加合理的方向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> implicit.nearest_neighbours <span class="keyword">import</span> bm25_weight</span><br><span class="line"><span class="keyword">from</span> implicit.als <span class="keyword">import</span> AlternatingLeastSquares</span><br><span class="line"></span><br><span class="line">model = AlternatingLeastSquares(factors=<span class="number">50</span>, regularization=<span class="number">0.01</span>, iterations = <span class="number">50</span>)</span><br><span class="line">model.fit(bm25_weight(plays.T.tocsr()))</span><br><span class="line"></span><br><span class="line">user_factors = model.user_factors</span><br><span class="line">artist_factors = model.item_factors</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 50.0/50 [20:15&lt;00:00, 23.36s/it]</code></pre><h2 id="获取相似artists"><a href="#获取相似artists" class="headerlink" title="获取相似artists"></a>获取相似artists</h2><p>生成两矩阵后，表示用户u和artist i的低维稠密向量分别为<code>user_factors[u]</code>与<code>artist_factors[i]</code>，它们维数相同。在显示反馈中可用来做用户u对物品i的评分预测，两向量求点积即可；同时，对于两个artists的隐因子向量<code>artist_factors[i1]</code>与<code>artist_factors[i2]</code>，依然可以使用余弦相似度公式来计算两者之间的相似度。</p><p>问题依然存在，要找到与artist i最相似的几个artists，需要遍历30万隐因子向量计算并排序，这个代价依然是巨大的。既然这里现在有这个问题，那么Spotify肯定早就遇到了，它曾经的推荐组技术带头人Erik Bernhardsson使用C++与Python写了一个用于解决这种近临搜索问题的库<a href="https://github.com/spotify/annoy">annoy</a>，使用起来就是建立一个索引把向量加入进去，搜索时拿着索引去搜很快能得到结果，Approximate Nearest Neighbors，这个Approximate是指在时间与相似程度准确度上进行了取舍。另外相似的工具还有nmslib与facebook开源的<a href="https://github.com/facebookresearch/faiss">faiss</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> annoy <span class="keyword">import</span> AnnoyIndex</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">artist_nn_index = AnnoyIndex(<span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(artist_factors.shape[<span class="number">0</span>]):</span><br><span class="line">    artist_nn_index.add_item(i, artist_factors[i])</span><br><span class="line"></span><br><span class="line">artist_nn_index.build(<span class="number">25</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_similar_artists</span>(<span class="params">artist, n = <span class="number">20</span></span>):</span></span><br><span class="line">    similar_artist_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> artist_nn_index.get_nns_by_item(artist, n):</span><br><span class="line">        similar_artist_list.append(df[<span class="string">&#x27;artist&#x27;</span>].cat.categories[i])</span><br><span class="line">    <span class="keyword">return</span> similar_artist_list</span><br><span class="line"></span><br><span class="line">yes = get_col_index_by_artist(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line">the_clash = get_col_index_by_artist(<span class="string">&#x27;the clash&#x27;</span>)</span><br><span class="line">the_smiths = get_col_index_by_artist(<span class="string">&#x27;the smiths&#x27;</span>)</span><br><span class="line">pink_floyd = get_col_index_by_artist(<span class="string">&#x27;pink floyd&#x27;</span>)</span><br><span class="line">blur = get_col_index_by_artist(<span class="string">&#x27;blur&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;yes similar artists:\n&#x27;</span>, get_similar_artists(yes))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;the_clash similar artists:\n&#x27;</span>, get_similar_artists(the_clash))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;the_smiths similar artists:\n&#x27;</span>, get_similar_artists(the_smiths))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;pink_floyd similar artists:\n&#x27;</span>, get_similar_artists(pink_floyd))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;blur similar artists:\n&#x27;</span>, get_similar_artists(blur))</span><br></pre></td></tr></table></figure><pre><code>yes similar artists: [&#39;yes&#39;, &#39;emerson, lake &amp; palmer&#39;, &#39;genesis&#39;, &#39;rush&#39;, &#39;jethro tull&#39;, &#39;king crimson&#39;, &#39;gentle giant&#39;, &#39;the moody blues&#39;, &#39;the alan parsons project&#39;, &#39;camel&#39;, &#39;kansas&#39;, &#39;david gilmour&#39;, &#39;focus&#39;, &#39;supertramp&#39;, &#39;jeff beck&#39;, &#39;roger waters&#39;, &#39;peter gabriel&#39;, &#39;steely dan&#39;, &#39;marillion&#39;, &#39;van der graaf generator&#39;]----------the_clash similar artists: [&#39;the clash&#39;, &#39;ramones&#39;, &#39;pixies&#39;, &#39;iggy pop&#39;, &#39;david bowie&#39;, &#39;the pogues&#39;, &#39;the specials&#39;, &#39;the smiths&#39;, &#39;the rolling stones&#39;, &#39;the cure&#39;, &#39;the white stripes&#39;, &#39;lou reed&#39;, &#39;violent femmes&#39;, &#39;the velvet underground&#39;, &#39;johnny cash&#39;, &#39;joy division&#39;, &#39;beastie boys&#39;, &#39;the kinks&#39;, &#39;nirvana&#39;, &#39;misfits&#39;]----------the_smiths similar artists: [&#39;the smiths&#39;, &#39;morrissey&#39;, &#39;the cure&#39;, &#39;joy division&#39;, &#39;david bowie&#39;, &#39;pixies&#39;, &#39;echo &amp; the bunnymen&#39;, &#39;the clash&#39;, &#39;the jesus and mary chain&#39;, &#39;pulp&#39;, &#39;interpol&#39;, &#39;the velvet underground&#39;, &#39;sonic youth&#39;, &#39;arcade fire&#39;, &#39;elliott smith&#39;, &#39;radiohead&#39;, &#39;my bloody valentine&#39;, &#39;blur&#39;, &#39;lou reed&#39;, &#39;nick drake&#39;]----------pink_floyd similar artists: [&#39;pink floyd&#39;, &#39;led zeppelin&#39;, &#39;the doors&#39;, &#39;jimi hendrix&#39;, &#39;queen&#39;, &#39;jethro tull&#39;, &#39;the police&#39;, &#39;jefferson airplane&#39;, &#39;the jimi hendrix experience&#39;, &#39;the who&#39;, &#39;creedence clearwater revival&#39;, &#39;the rolling stones&#39;, &#39;nirvana&#39;, &#39;dire straits&#39;, &#39;deep purple&#39;, &#39;genesis&#39;, &#39;santana&#39;, &#39;david gilmour&#39;, &#39;john lennon&#39;, &#39;pearl jam&#39;]----------blur similar artists: [&#39;blur&#39;, &#39;franz ferdinand&#39;, &#39;supergrass&#39;, &#39;pulp&#39;, &#39;the dandy warhols&#39;, &#39;the verve&#39;, &#39;manic street preachers&#39;, &#39;the white stripes&#39;, &#39;oasis&#39;, &#39;the stone roses&#39;, &#39;beck&#39;, &#39;primal scream&#39;, &#39;arctic monkeys&#39;, &#39;the coral&#39;, &#39;kasabian&#39;, &#39;david bowie&#39;, &#39;eels&#39;, &#39;the smiths&#39;, &#39;kaiser chiefs&#39;, &#39;new order&#39;]</code></pre><p>得到的结果令人欣喜。    </p><p>yes的相似列表里有king crimson，rush，emerson, lake &amp; palmer，genesis，都是前卫得不行的乐队，在前卫摇滚全家福上很容易找到他们的身影；<br>the clash的列表中ramones，pixies，iggy pop都是朋克乐队，joy division与the clash都是1976年成立，前者是后朋的先驱，看到the velvet underground真的笑出声，毕竟“每一位朋克、后朋克和先锋流行艺术家在过去的30年中都欠下了‘地下丝绒’乐队一笔灵感的债务，哪怕只是受到了间接的影响。”；<br>the smiths是上个世纪80年代英国独立摇滚的代表，列表中第一位是主唱莫老师，然后有同时期的joy division，echo &amp; the bunnymen，都是独立摇滚的代表；<br>pink floyd的列表也不必多说，关键字70年代，同一时期历史评价极高的几支乐队都在推荐之列；<br>最后看到blur的列表里面有pulp和oasis，就放心了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://yifanhu.net/PUB/cf.pdf">《Collaborative Filtering for Implicit Feedback Datasets》</a><br><a href="https://www.benfrederickson.com/matrix-factorization/">Finding Similar Music using Matrix Factorization</a><br><a href="https://jessesw.com/Rec-System/">A Gentle Introduction to Recommender Systems with Implicit Feedback</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在网易云音乐中，点入某歌手主页时会有一栏为相似歌手：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/guerbai/scene/main/blog/aefe5c43cb674b203c42b9ae07907363.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Yes是1968年成立的著名前卫摇滚乐队，云音乐中与其相似的列表中有Rush，而后者则是来自加拿大的一支异常出色的前卫摇滚乐队，这对于一个喜爱前卫摇滚的听众来说，当然是一个很不错的推荐。然而，Yes的推荐列表中的第一位是Coda(小田和奏)，此君是何许人也，此君并不像Rush、Yes一样是几十年前便成立并在摇滚史上留下浓墨重彩的前卫摇滚音乐人，那云音乐又为何会把此君放在Yes相似列表的第一位呢？ &lt;/p&gt;</summary>
    
    
    
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="算法" scheme="http://guerbai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Shining Music</title>
    <link href="http://guerbai.github.io/2019/02/23/shining-music/"/>
    <id>http://guerbai.github.io/2019/02/23/shining-music/</id>
    <published>2019-02-23T06:12:46.000Z</published>
    <updated>2021-11-06T08:53:26.439Z</updated>
    
    <content type="html"><![CDATA[<p>在一个更高的角度上讲，音乐推荐系统可以包含<strong>机器推荐</strong>与<strong>人工推荐</strong>两个部分，对于前者会用很多篇文章花大笔墨去说各种算法实现过程与业内做法和经验；而在人工推荐，或者称为<strong>编辑推荐</strong>方面，由于笔者近几年收听唱片无数，对上个世纪60年代以来英美主流摇滚音乐、文化有着些许了解，于此处列出一些精品，或有同好若可交流一二即不胜欣喜。</p><span id="more"></span><p><strong>注</strong>：有些乐队的作品是不需要单独列出的，比如The Beatles、Pink Floyd、Led Zeppelin、The Doors，几乎每一张都很棒，去听就完事儿了。</p><h2 id="国外专辑"><a href="#国外专辑" class="headerlink" title="国外专辑"></a>国外专辑</h2><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/bad2dbf2a4b9d597912cf8186c2c386b.jpg"><br>Television - 《Marquee Moon》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/52032fc3496f4d3618039fdbeb5ad765.jpg"><br>Love - 《Forever Changes》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/9d7ead6bd38be556bba04f97326f910f.jpg"><br>King Crimson - 《In the Court of the Crimson King》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/5d3d07668f7fb204b2c053122a03f830.jpg"><br>Joy Division - 《Unknown Pleasures》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/36044b820574d600d2d1fdd8c3937ce7.jpg"><br>Queen - 《A Night at the Opera》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/7bd5aa527550ee53f8409b51c82c54d7.jpg"><br>Black Sabbath - 《Paranoid》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/9dfb3095ba0675ddf109430ef392a045.jpg"><br>John Lennon - 《John Lennon/Plastic Ono Band》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/ca190e71ce9f3085c79a0a773d3a8911.jpg"><br>Janis Joplin - 《Pearl》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/f56a96613d2d47e3a2919f2f056fe743.jpg"><br>AC/DC - 《Back in Black》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/899126d15d326c4774081d0e6e3b89fa.jpg"><br>Dire Straits - 《On the Night》(Live)</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/59daa7660e8847324116e0e21f7b7c9e.jpg"><br>The Stone Roses - 《The Stone Roses》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/2ebbf5b67f6259a4eccd6c35449cad9f.jpg"><br>Radiohead - 《OK Computer》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/6a22935a1601643baab3746b1240b567.jpg"><br>Metallica - 《Master of Puppets》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/42f0f2724aa3918d5b8320bcb181be63.jpg"><br>Carpenters - 《Now &amp; Then》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/73bffd377baf4106cff7eca8150ff220.jpg"><br>Rush - 《2112》</p><div><h2 id="国内专辑"><a href="#国内专辑" class="headerlink" title="国内专辑"></a>国内专辑</h2><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/434a46573bee15e1f6d79784f73ae1fe.jpg"><br>窦唯 - 《黑梦》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/2a64cfd604cd203c160136bf295a9387.jpg"><br>万能青年旅店 - 《万能青年旅店》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/0e96f62e6562989added6d20083aab60.jpg"><br>刺猬 - 《幻象波普星》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/eb2f51f058ca3a949ba2e34268a05397.jpg"><br>重塑雕像的权利 - 《WATCH OUT! CLIMATE HAS CHANGED，FAT MUM RISES…》</p><div><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/b35d77b6d44247e4974973412ff2232e.jpg"><br>落日飞车 - 《Cassa Nova》</p><div><p>选择的基本是整张听下来都很棒而不是只有一两首不错的这种，当然由于记性、知识面、个人口味问题，必然遗漏了很多优秀的作品，动态维护吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个更高的角度上讲，音乐推荐系统可以包含&lt;strong&gt;机器推荐&lt;/strong&gt;与&lt;strong&gt;人工推荐&lt;/strong&gt;两个部分，对于前者会用很多篇文章花大笔墨去说各种算法实现过程与业内做法和经验；而在人工推荐，或者称为&lt;strong&gt;编辑推荐&lt;/strong&gt;方面，由于笔者近几年收听唱片无数，对上个世纪60年代以来英美主流摇滚音乐、文化有着些许了解，于此处列出一些精品，或有同好若可交流一二即不胜欣喜。&lt;/p&gt;</summary>
    
    
    
    
    <category term="摇滚乐" scheme="http://guerbai.github.io/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Slope One进行评分预测</title>
    <link href="http://guerbai.github.io/2019/02/20/slopeone/"/>
    <id>http://guerbai.github.io/2019/02/20/slopeone/</id>
    <published>2019-02-20T08:17:35.000Z</published>
    <updated>2021-11-06T08:53:26.439Z</updated>
    
    <content type="html"><![CDATA[<p>Slope One是一种基于物品的协同过滤算法，在2005年的paper《Slope One Predictors for Online Rating-Based Collaborative Filtering》被提出，用于预测用户对某一给定的物品的评分。</p><p>依然使用<a href="https://guerbai.github.io/2019/02/16/intro-to-collaborative-filtering/">上一篇</a>中提到的自己编造的少量<a href="https://gist.githubusercontent.com/guerbai/3f4964350678c84d359e3536a08f6d3a/raw/f62f26d9ac24d434b1a0be3b5aec57c8a08e7741/user_book_ratings.txt">评分数据</a>来描述该算法的运作机制。    </p><span id="more"></span><p>首先依然是加载数据和生成用户物品关系矩阵如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_url = <span class="string">&#x27;https://gist.githubusercontent.com/guerbai/3f4964350678c84d359e3536a08f6d3a/raw/f62f26d9ac24d434b1a0be3b5aec57c8a08e7741/user_book_ratings.txt&#x27;</span></span><br><span class="line">df = pd.read_csv(data_url, sep = <span class="string">&#x27;,&#x27;</span>, header = <span class="literal">None</span>, names = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;book_id&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>])</span><br><span class="line">user_count = df[<span class="string">&#x27;user_id&#x27;</span>].unique().shape[<span class="number">0</span>]</span><br><span class="line">item_count = df[<span class="string">&#x27;book_id&#x27;</span>].unique().shape[<span class="number">0</span>]</span><br><span class="line">user_id_index_series = pd.Series(<span class="built_in">range</span>(user_count), index=[<span class="string">&#x27;user_001&#x27;</span>, <span class="string">&#x27;user_002&#x27;</span>, <span class="string">&#x27;user_003&#x27;</span>, <span class="string">&#x27;user_004&#x27;</span>, <span class="string">&#x27;user_005&#x27;</span>, <span class="string">&#x27;user_006&#x27;</span>])</span><br><span class="line">item_id_index_series = pd.Series(<span class="built_in">range</span>(item_count), index=[<span class="string">&#x27;book_001&#x27;</span>, <span class="string">&#x27;book_002&#x27;</span>, <span class="string">&#x27;book_003&#x27;</span>, <span class="string">&#x27;book_004&#x27;</span>, <span class="string">&#x27;book_005&#x27;</span>, <span class="string">&#x27;book_006&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct_user_item_matrix</span>(<span class="params">df</span>):</span></span><br><span class="line">    user_item_matrix = np.zeros((user_count, item_count), dtype=np.int8)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">        user_id = row[<span class="number">1</span>]</span><br><span class="line">        book_id = row[<span class="number">2</span>]</span><br><span class="line">        rating = row[<span class="number">3</span>]</span><br><span class="line">        user_item_matrix[user_id_index_series[user_id], item_id_index_series[book_id]] = rating</span><br><span class="line">    <span class="keyword">return</span> user_item_matrix</span><br><span class="line"></span><br><span class="line">user_item_matrix = construct_user_item_matrix(df)</span><br><span class="line"><span class="built_in">print</span> (user_item_matrix)</span><br></pre></td></tr></table></figure><pre><code>[[4 3 0 0 5 0] [5 0 4 0 4 0] [4 0 5 3 4 0] [0 3 0 0 0 5] [0 4 0 0 0 4] [0 0 2 4 0 5]]</code></pre><h2 id="构造物品评分差异矩阵"><a href="#构造物品评分差异矩阵" class="headerlink" title="构造物品评分差异矩阵"></a>构造物品评分差异矩阵</h2><p>接下来生成两个shape为<code>(item_count, item_count)</code>的矩阵<code>differential_matrix</code>与<code>weight_matrix</code>。<br>前者记录物品两两之间的被评分差异情况，后者记录对某两个物品共同评分的人数，用于之后的计算做加权。</p><p>以上面<code>user_item_matrix</code>举例来讲，index为2与4的item的共同评分人数为2(index为1与2的用户)，则计算这两者的评分差异为:<br><code>((4-4)+(5-4))/2 = 0.5</code>，故在<code>differential_matrix[2][4]</code>的位置填上0.5，同时在<code>weight_matrix[2][4]</code>的位置填上2。<br>同时，反过来，<code>differential_matrix[4][2]</code>的值为-0.5，而<code>weight_matrix[4][2]</code>的位置依然为2，这种相对应的位置不需要重复计算了。</p><p>下面的函数接受一个用户物品关系矩阵，按照上述方法计算出这两个矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_differential</span>(<span class="params">ratings</span>):</span></span><br><span class="line">    item_count = ratings.shape[<span class="number">1</span>]</span><br><span class="line">    differential_matrix = np.zeros((item_count, item_count))</span><br><span class="line">    weight_matrix = np.zeros((item_count, item_count))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item_count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, item_count):</span><br><span class="line">            differential = <span class="number">0</span></span><br><span class="line">            i_rating_user_indexes = ratings[:, i].nonzero()[<span class="number">0</span>]</span><br><span class="line">            j_rating_user_indexes = ratings[:, j].nonzero()[<span class="number">0</span>]</span><br><span class="line">            rating_i_j_user = <span class="built_in">set</span>(i_rating_user_indexes).intersection(<span class="built_in">set</span>(j_rating_user_indexes))</span><br><span class="line">            user_count = <span class="built_in">len</span>(rating_i_j_user)</span><br><span class="line">            <span class="keyword">if</span> user_count == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> user_index <span class="keyword">in</span> rating_i_j_user:</span><br><span class="line">                differential += ratings[user_index][i] - ratings[user_index][j]</span><br><span class="line">            weight_matrix[i][j] = user_count</span><br><span class="line">            weight_matrix[j][i] = user_count</span><br><span class="line">            differential_matrix[i][j] = <span class="built_in">round</span>(differential/user_count, <span class="number">2</span>)</span><br><span class="line">            differential_matrix[j][i] = -differential_matrix[i][j]</span><br><span class="line">    <span class="keyword">return</span> differential_matrix, weight_matrix</span><br><span class="line"></span><br><span class="line">differential_matrix, weight_matrix = compute_differential(user_item_matrix)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;differential_matrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (differential_matrix)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;-----&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;weight_matrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (weight_matrix)</span><br></pre></td></tr></table></figure><pre><code>differential_matrix[[ 0.   1.   0.   1.   0.   0. ] [-1.   0.   0.   0.  -2.  -1. ] [-0.   0.   0.   0.   0.5 -3. ] [-1.   0.  -0.   0.  -1.  -1. ] [-0.   2.  -0.5  1.   0.   0. ] [ 0.   1.   3.   1.   0.   0. ]]-----weight_matrix[[ 0.  1.  2.  1.  3.  0.] [ 1.  0.  0.  0.  1.  2.] [ 2.  0.  0.  2.  2.  1.] [ 1.  0.  2.  0.  1.  1.] [ 3.  1.  2.  1.  0.  0.] [ 0.  2.  1.  1.  0.  0.]]</code></pre><h2 id="进行评分预测"><a href="#进行评分预测" class="headerlink" title="进行评分预测"></a>进行评分预测</h2><p>得到上述两个矩阵后可以根据用户的历史评分，为其进行未发生过评分关联的某物品的评分预测。</p><p>比如要为index为1的用户<code>user_002</code>预测其对index为3的物品<code>item_004</code>的评分，计算过程如下：<br>先取出该用户看过的所有书，index分别为<code>[0, 2, 4]</code>;<br>以index为0的物品<code>item_001</code>开始，查<code>differential_matrix[3][0]</code>值为-1，表示<code>item_004</code>平均上比<code>item_001</code>低1分，以该用户对<code>item_001</code>的评分为5为基准，<code>5+(-1)=4</code>，则利用<code>item_001</code>可对<code>item_004</code>做出的评分判断为4分，查<code>weight_matrix</code>表知道同时评分过这两个物品的用户只有一个，置信度不够高，使用<code>4*1=4</code>，这便是加权的含义；<br>但这还没完，再根据index为2、4的item分别做上一步，并将得到的值加和为15，作为分子，分母为每次计算的人数之和，即加权平均，为4；<br>最后得此次预测评分为<code>15/4=3.75</code>。    </p><p>下面的函数接受五个参数，分别为三个矩阵，用户id，物品id，结果为预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">ratings, differential_matrix, weight_matrix, user_index, item_index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> ratings[user_index][item_index] != <span class="number">0</span>: <span class="keyword">return</span> ratings[user_index][item_index]</span><br><span class="line">    fenzi = <span class="number">0</span></span><br><span class="line">    fenmu = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> rated_item_index <span class="keyword">in</span> ratings[user_index].nonzero()[<span class="number">0</span>]:</span><br><span class="line">        fenzi += weight_matrix[item_index][rated_item_index] * \</span><br><span class="line">            (differential_matrix[item_index][rated_item_index] + ratings[user_index][rated_item_index])</span><br><span class="line">        fenmu += weight_matrix[rated_item_index][item_index]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(fenzi/fenmu, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict(user_book_matrix, book_differential, weight_matrix, <span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.75</code></pre><h2 id="新的评分数据"><a href="#新的评分数据" class="headerlink" title="新的评分数据"></a>新的评分数据</h2><p>当某用户对某个其之间未评分过的物品进行一次新的评分时，需要更新三个矩阵的值。令人欣喜的是，Slope One的计算过程使得这种更新非常迅速，时间复杂度仅为O(x)，其中x为该用户之前评过分的所有物品的数量。</p><p>理所当然要在<code>user_item_matrix</code>填入评分值，此外，对此index为i的物品，需要与那x个物品依次组合在<code>weight_matrix</code>中将值增加1。同理<code>differential_matrix</code>也只需要累计上新的差值即可。<br>一个用户评价过的物品数目是很有限的，这种更新模型的方法可谓飞快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_matrices</span>(<span class="params">user_index, item_index, rating</span>):</span></span><br><span class="line">    rated_item_indexes = user_item_matrix[user_index].nonzero()[<span class="number">0</span>]</span><br><span class="line">    user_item_matrix[user_index][item_index] = rating</span><br><span class="line">    <span class="keyword">for</span> rated_item_index <span class="keyword">in</span> rated_item_indexes:</span><br><span class="line">        old_weight = weight_matrix[rated_item_index][item_index]</span><br><span class="line">        weight_matrix[rated_item_index][item_index] += <span class="number">1</span></span><br><span class="line">        weight_matrix[item_index][rated_item_index] += <span class="number">1</span></span><br><span class="line">        differential_matrix[rated_item_index][item_index] = (differential_matrix[rated_item_index][item_index] \</span><br><span class="line">            * old_weight + (user_item_matrix[user_index][rated_item_index] - rating)) / (old_weight + <span class="number">1</span>)</span><br><span class="line">        differential_matrix[item_index][rated_item_index] = (differential_matrix[item_index][rated_item_index] \</span><br><span class="line">            * old_weight + (rating - user_item_matrix[user_index][rated_item_index])) / (old_weight + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p><strong>简单易懂</strong>：参见代码；<br><strong>存储</strong>：存储上除了<code>user_item_matrix</code>，还需要存下<code>differential_matrix</code>与<code>weight_matrix</code>，为节省空间，可以只存后两者的对角线的右上部分即可；<br><strong>预测时间复杂度</strong>：用户评价过的物品数为x，由predict代码，则做一次预测的时间复杂度为O(x)；<br><strong>更新时间复杂度</strong>：当用户新进行一次评分时，由update_matrices代码，时间复杂度为O(x);<br><strong>新用户友好</strong>：当用户仅进行少量评分时，即可为其进行较高质量的推荐。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.researchgate.net/publication/1960789_Slope_One_Predictors_for_Online_Rating-Based_Collaborative_Filtering">《Slope One Predictors for Online Rating-Based Collaborative Filtering》</a><br><a href="https://zh.wikipedia.org/wiki/Slope_one">Slope One wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Slope One是一种基于物品的协同过滤算法，在2005年的paper《Slope One Predictors for Online Rating-Based Collaborative Filtering》被提出，用于预测用户对某一给定的物品的评分。&lt;/p&gt;
&lt;p&gt;依然使用&lt;a href=&quot;https://guerbai.github.io/2019/02/16/intro-to-collaborative-filtering/&quot;&gt;上一篇&lt;/a&gt;中提到的自己编造的少量&lt;a href=&quot;https://gist.githubusercontent.com/guerbai/3f4964350678c84d359e3536a08f6d3a/raw/f62f26d9ac24d434b1a0be3b5aec57c8a08e7741/user_book_ratings.txt&quot;&gt;评分数据&lt;/a&gt;来描述该算法的运作机制。    &lt;/p&gt;</summary>
    
    
    
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="算法" scheme="http://guerbai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基于邻域的协同过滤</title>
    <link href="http://guerbai.github.io/2019/02/16/intro-to-collaborative-filtering/"/>
    <id>http://guerbai.github.io/2019/02/16/intro-to-collaborative-filtering/</id>
    <published>2019-02-16T06:57:00.000Z</published>
    <updated>2021-11-06T08:53:26.435Z</updated>
    
    <content type="html"><![CDATA[<p>此篇使用朴素的代码介绍基于邻域的协同过滤算法机制。</p><p>为了使说明过程更清楚，这里使用<a href="https://gist.githubusercontent.com/guerbai/3f4964350678c84d359e3536a08f6d3a/raw/f62f26d9ac24d434b1a0be3b5aec57c8a08e7741/user_book_ratings.txt">自已编造的数据</a>。每一行记录着某用户对某本书的评分，评分区间为1至5。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data_url = <span class="string">&#x27;https://gist.githubusercontent.com/guerbai/3f4964350678c84d359e3536a08f6d3a/raw/f62f26d9ac24d434b1a0be3b5aec57c8a08e7741/user_book_ratings.txt&#x27;</span></span><br><span class="line">df = pd.read_csv(data_url, </span><br><span class="line">            sep = <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            header = <span class="literal">None</span>,                   </span><br><span class="line">            names = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;book_id&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (df.head())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;-----&#x27;</span>)</span><br><span class="line">user_count = df[<span class="string">&#x27;user_id&#x27;</span>].unique().shape[<span class="number">0</span>]</span><br><span class="line">book_count = df[<span class="string">&#x27;book_id&#x27;</span>].unique().shape[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;user_count: &#x27;</span>, user_count)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;book_count: &#x27;</span>, book_count)</span><br></pre></td></tr></table></figure><pre><code>    user_id   book_id  rating0  user_001  book_001       41  user_001  book_002       32  user_001  book_005       53  user_002  book_001       54  user_002  book_003       4-----user_count:  6book_count:  6</code></pre><h2 id="生成用户物品关系矩阵"><a href="#生成用户物品关系矩阵" class="headerlink" title="生成用户物品关系矩阵"></a>生成用户物品关系矩阵</h2><p>现在根据加载进来的数据生成推荐系统中至关重要的用户物品关系矩阵。可以理解为数据库中的一张表，一本书为一列，一行对应一个用户，当用户看过某本书并进行评分后，在对应的位置填入分数，其他位置均置为0，表示尚未看过。</p><p>需要注意的是，矩阵取值要用下标表示，比如<code>matrix[2][2]</code>对应的是第三个用户对第三本书的评分情况，所以这里要做一个<code>user_id</code>, <code>book_id</code>到该矩阵坐标的对应关系，使用pandas的Series表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_id_index_series = pd.Series(<span class="built_in">range</span>(user_count), index=[<span class="string">&#x27;user_001&#x27;</span>, <span class="string">&#x27;user_002&#x27;</span>, <span class="string">&#x27;user_003&#x27;</span>, <span class="string">&#x27;user_004&#x27;</span>, <span class="string">&#x27;user_005&#x27;</span>, <span class="string">&#x27;user_006&#x27;</span>])</span><br><span class="line">book_id_index_series = pd.Series(<span class="built_in">range</span>(book_count), index=[<span class="string">&#x27;book_001&#x27;</span>, <span class="string">&#x27;book_002&#x27;</span>, <span class="string">&#x27;book_003&#x27;</span>, <span class="string">&#x27;book_004&#x27;</span>, <span class="string">&#x27;book_005&#x27;</span>, <span class="string">&#x27;book_006&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct_user_item_matrix</span>(<span class="params">df</span>):</span></span><br><span class="line">    user_item_matrix = np.zeros((user_count, book_count), dtype=np.int8)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">        user_id = row[<span class="number">1</span>]</span><br><span class="line">        book_id = row[<span class="number">2</span>]</span><br><span class="line">        rating = row[<span class="number">3</span>]</span><br><span class="line">        user_item_matrix[user_id_index_series[user_id], book_id_index_series[book_id]] = rating</span><br><span class="line">    <span class="keyword">return</span> user_item_matrix</span><br><span class="line"></span><br><span class="line">user_book_matrix = construct_user_item_matrix(df)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;用户关系矩阵长这样：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;-----&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (user_book_matrix)</span><br></pre></td></tr></table></figure><pre><code>用户关系矩阵长这样：-----[[4 3 0 0 5 0] [5 0 4 0 4 0] [4 0 5 3 4 0] [0 3 0 0 0 5] [0 4 0 0 0 4] [0 0 2 4 0 5]]</code></pre><h2 id="计算相似度矩阵"><a href="#计算相似度矩阵" class="headerlink" title="计算相似度矩阵"></a>计算相似度矩阵</h2><p>所谓相似度，我们这里使用余弦相似度，其他的还有皮尔逊相关度、欧式距离、杰卡德相似度等，个中差别暂不细表。<br>计算公式为：</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/190fdce53dc3115406f3661c89fadd77.jpg"></p><p>现在已经拿到了<code>user_book_matrix</code>，每个用户、每个物品都可以对应一个向量，比如<code>user_book_matrix[2]</code>为代表<code>user_003</code>的向量等于<code>[4, 0, 5, 3, 4, 0]</code>，而<code>user_book_matrix[:,2]</code>则代表了<code>book_003</code>：<code>[0， 4， 5， 0， 0， 2]</code>。</p><p>这样基于用户和基于物品便分别可以计算出用户相似度矩阵与物品相似度矩阵。</p><p>以用户相似度矩阵为例，计算后会得到一个形状为(user_count, user_count)的矩阵，比如<code>user_similarity_matrix[2][3]</code>的值为0.5，则表示<code>user_002</code>与<code>user_003</code>的余弦相似度为0.5。<br>此矩阵为对称矩阵，相应地，<code>user_similarity_matrix[3][2]</code>亦为0.5，而用户与自己自然是最相似的，遂有<code>user_similarity_matrix[n][n]</code>总是等于1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cosine_similarity</span>(<span class="params">vec1, vec2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(vec1.dot(vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2)), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct_similarity_matrix</span>(<span class="params">user_item_matrix, dim=<span class="string">&#x27;user&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> dim == <span class="string">&#x27;user&#x27;</span>:</span><br><span class="line">        similarity_matrix = np.zeros((user_count, user_count))</span><br><span class="line">        count = user_count</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        similarity_matrix = np.zeros((book_count, book_count))</span><br><span class="line">        count = book_count</span><br><span class="line">    get_vector = <span class="keyword">lambda</span> i: user_item_matrix[i] <span class="keyword">if</span> dim == <span class="string">&#x27;user&#x27;</span> <span class="keyword">else</span> user_item_matrix[:,i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(user_count):</span><br><span class="line">        i_vector = get_vector(i)</span><br><span class="line">        similarity_matrix[i][i] = cosine_similarity(i_vector, i_vector)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, count):</span><br><span class="line">            j_vector = get_vector(j)</span><br><span class="line">            similarity = cosine_similarity(i_vector, j_vector)</span><br><span class="line">            similarity_matrix[i][j] = similarity</span><br><span class="line">            similarity_matrix[j][i] = similarity</span><br><span class="line">    <span class="keyword">return</span> similarity_matrix</span><br><span class="line"></span><br><span class="line">user_similarity_matrix = construct_similarity_matrix(user_book_matrix)</span><br><span class="line">book_similarity_matrix = construct_similarity_matrix(user_book_matrix, dim=<span class="string">&#x27;book&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;user_similarity_matrix:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (user_similarity_matrix)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;book_similarity_matrix:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (book_similarity_matrix)</span><br></pre></td></tr></table></figure><pre><code>user_similarity_matrix:[[1.   0.75 0.63 0.22 0.3  0.  ] [0.75 1.   0.91 0.   0.   0.16] [0.63 0.91 1.   0.   0.   0.4 ] [0.22 0.   0.   1.   0.97 0.64] [0.3  0.   0.   0.97 1.   0.53] [0.   0.16 0.4  0.64 0.53 1.  ]]book_similarity_matrix:[[1.   0.27 0.79 0.32 0.98 0.  ] [0.27 1.   0.   0.   0.34 0.65] [0.79 0.   1.   0.69 0.71 0.18] [0.32 0.   0.69 1.   0.32 0.49] [0.98 0.34 0.71 0.32 1.   0.  ] [0.   0.65 0.18 0.49 0.   1.  ]]</code></pre><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>有了相似度矩阵，可以开始进行推荐。<br>首先可以为用户推荐与其品味相同的用户列表，这在知乎、豆瓣、网易云音乐这样具有社交属性的产品中很有意义。</p><p>做法很简单，要为用户A推荐K位品味相似的用户(此处K取3)，则将<code>user_similarity_matrix</code>中关于A的那一行的值排序从最高往下取出K位即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend_similar_users</span>(<span class="params">user_id, n=<span class="number">3</span></span>):</span></span><br><span class="line">    user_index = user_id_index_series[user_id]</span><br><span class="line">    similar_users_index = pd.Series(user_similarity_matrix[user_index]).drop(index=user_index).sort_values(ascending=<span class="literal">False</span>).index[:n]</span><br><span class="line">    <span class="keyword">return</span> np.array(similar_users_index)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;recommend user_indexes %s to user_001&#x27;</span> % recommend_similar_users(<span class="string">&#x27;user_001&#x27;</span>))</span><br></pre></td></tr></table></figure><pre><code>recommend user_indexes [1 2 4] to user_001</code></pre><p>同时在物品维度，类似的推荐也是很有用的，比如QQ音乐给用户正在听的音乐推荐相似的歌曲，还有亚马逊中对用户刚购买的物品推荐相似的物品。<br>代码与推荐相似用户相同，无需做其他处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend_similar_items</span>(<span class="params">item_id, n=<span class="number">3</span></span>):</span></span><br><span class="line">    item_index = book_id_index_series[item_id]</span><br><span class="line">    similar_item_index = pd.Series(book_similarity_matrix[item_index]).drop(index=item_index).sort_values(ascending=<span class="literal">False</span>).index[:n]</span><br><span class="line">    <span class="keyword">return</span> np.array(similar_item_index)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;recommend item_indexes %s to book_001&#x27;</span> % recommend_similar_items(<span class="string">&#x27;book_001&#x27;</span>))</span><br></pre></td></tr></table></figure><pre><code>recommend item_indexes [4 2 3] to book_001</code></pre><p>接下来是为用户推荐书籍，首先选出与该用户最相似的K个用户，然后找出这K个用户评过分的书籍的集合，再去掉该用户已经评过分的部分。<br>在剩下的书籍中，根据下面的公式，计算出该用户为某书籍的预计评分，将评分从高到低排序输出即可。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/84bf01e478190752aa7a91dcfe3249fa.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend_item_to_user</span>(<span class="params">user_id</span>):</span></span><br><span class="line">    user_index = user_id_index_series[user_id]</span><br><span class="line">    similar_users = recommend_similar_users(user_id, <span class="number">2</span>)</span><br><span class="line">    recommend_set = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> similar_user <span class="keyword">in</span> similar_users:</span><br><span class="line">        recommend_set = recommend_set.union(np.nonzero(user_book_matrix[similar_user])[<span class="number">0</span>])</span><br><span class="line">    recommend_set = recommend_set.difference(np.nonzero(user_book_matrix[user_index])[<span class="number">0</span>])</span><br><span class="line">    predict = pd.Series([<span class="number">0.0</span>]*<span class="built_in">len</span>(recommend_set), index=<span class="built_in">list</span>(recommend_set))</span><br><span class="line">    <span class="keyword">for</span> book_index <span class="keyword">in</span> recommend_set:</span><br><span class="line">        fenzi = <span class="number">0</span></span><br><span class="line">        fenmu = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> similar_users:</span><br><span class="line">            <span class="keyword">if</span> user_book_matrix[j][book_index] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 相似用户未看过该书则不计入统计.</span></span><br><span class="line">            fenzi += user_book_matrix[j][book_index] * user_similarity_matrix[j][user_index]</span><br><span class="line">            fenmu += user_similarity_matrix[j][user_index]</span><br><span class="line">        <span class="keyword">if</span> fenmu == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        predict[book_index] = <span class="built_in">round</span>(fenzi/fenmu, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> predict.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">recommend_item_to_user(<span class="string">&#x27;user_005&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>3    4.02    2.0dtype: float64</code></pre><p>以上是利用用户相似度矩阵来为用户推荐物品，同样也可以反过来为利用物品相似度矩阵来为用户推荐书籍。<br>做法是，找出该用户读过的所有书，为每本书找出两本与该书最相似的书籍，将找出来的所有书去掉用户已读过的，然后为书籍预测被用户评分的分值。</p><p>这里的确有些绕，容易与上文缠在一起搞乱掉，遂举例如下：<br>比如<code>user_001</code>读过书<code>book_001</code>, <code>book_002</code>，<code>book_005</code>，找到的书籍集合再去掉用户已读过的结果为<code>&#123;&#39;book_003&#39;, &#39;book_006&#39;&#125;</code>，要为<code>book_003</code>预测分数，需要注意到它同时被<code>book_001</code>与<code>book_005</code>找出，要根据它们、用户对<code>book_001</code>与<code>book_005</code>的评分以及相似度套用至上文公式，来得出对<code>book_003</code>的分数为：<code>(4*0.79+5*0.71)/(0.79+0.71)=4.47</code>。</p><p>则基于物品为用户推荐物品的函数为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend_item_to_user_ib</span>(<span class="params">user_id</span>):</span></span><br><span class="line">    user_index = user_id_index_series[user_id]</span><br><span class="line">    user_read_books = np.nonzero(user_book_matrix[user_index])[<span class="number">0</span>]</span><br><span class="line">    book_set = <span class="built_in">set</span>()</span><br><span class="line">    book_relation = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> user_read_books:</span><br><span class="line">        relative_books = recommend_similar_items(book, <span class="number">2</span>)</span><br><span class="line">        book_set = book_set.union(relative_books)</span><br><span class="line">        book_relation[book] = relative_books</span><br><span class="line">    book_set = book_set.difference(user_read_books)</span><br><span class="line">    predict = pd.Series([<span class="number">0.0</span>]*<span class="built_in">len</span>(book_set), index=<span class="built_in">list</span>(book_set))</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> book_set:</span><br><span class="line">        fenzi = <span class="number">0</span></span><br><span class="line">        fenmu = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> similar_book, relative_books <span class="keyword">in</span> book_relation.items():</span><br><span class="line">            <span class="keyword">if</span> book <span class="keyword">in</span> relative_books:</span><br><span class="line">                fenzi += book_similarity_matrix[book][similar_book] * user_book_matrix[user_index][similar_book]</span><br><span class="line">                fenmu += book_similarity_matrix[book][similar_book]</span><br><span class="line">        predict[book] = <span class="built_in">round</span>(fenzi/fenmu, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> predict.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">recommend_item_to_user_ib(<span class="string">&#x27;user_001&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>2    4.475    3.00dtype: float64</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是基于领域的协同过滤的运作机制介绍，只用了两个简单的数学公式，加上各种代码处理，便可以为用户做出一些推荐。</p><p>就给用户推荐物品而言，基于用户与基于物品各有特点。<br>基于用户给出的推荐结果，更依赖于当前用户相近的用户群体的社会化行为，考虑到计算代价，它适合于用户数较少的情况，同时，对于新加入的物品的冷启动问题比较友好，然而相对于物品的相似性，根据用户之间的相似性做出的推荐的解释性是比较弱的，实时性方面，用户新的行为不一定会导致结果的变化。<br>基于物品给出的推荐结果，更侧重于用户自身的个体行为，适用于物品数较少的情况，对长尾物品的发掘好于基于用户，同时，新加入的用户可以很快得到推荐，并且物品之间的关联性更易懂，是更易于解释的，而且用户新的行为一定能导致结果的变化。</p><p>显然，基于物品总体上要优于基于用户，历史上，也的确是基于用户先被发明出来，之后Amazon发明了基于物品的算法，现在基于用户的产品已经比较少了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ethanrosenthal.com/2015/11/02/intro-to-collaborative-filtering/">Intro to Recommender Systems: Collaborative Filtering</a><br><a href="https://time.geekbang.org/column/article/4802">【近邻推荐】人以群分，你是什么人就看到什么世界</a><br><a href="https://www.infoq.cn/minibooks/recommendation-system-theroy">架构师特刊：推荐系统（理论篇）</a><br><a href="https://tech.meituan.com/2015/01/22/mt-recommend-practice.html">美团推荐算法实践</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇使用朴素的代码介绍基于邻域的协同过滤算法机制。&lt;/p&gt;
&lt;p&gt;为了使说明过程更清楚，这里使用&lt;a href=&quot;https://gist.githubusercontent.com/guerbai/3f4964350678c84d359e3536a08f6d3a/raw/f62f26d9ac24d434b1a0be3b5aec57c8a08e7741/user_book_ratings.txt&quot;&gt;自已编造的数据&lt;/a&gt;。每一行记录着某用户对某本书的评分，评分区间为1至5。&lt;/p&gt;</summary>
    
    
    
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="算法" scheme="http://guerbai.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>音乐数据集汇总</title>
    <link href="http://guerbai.github.io/2019/02/13/music-dataset/"/>
    <id>http://guerbai.github.io/2019/02/13/music-dataset/</id>
    <published>2019-02-13T06:17:57.000Z</published>
    <updated>2021-11-06T08:53:26.436Z</updated>
    
    <content type="html"><![CDATA[<p>接下来会研究一下音乐推荐系统，需要数据来进行算法及工程代码的演示，遂汇总一下网上开源的音乐数据集。</p><h1 id="Million-Song-Dataset"><a href="#Million-Song-Dataset" class="headerlink" title="Million Song Dataset"></a>Million Song Dataset</h1><p>说到音乐数据集第一位肯定是MSD，它包含了100万首歌曲的信息，总量有280GB大小。由于数据量的确较大，它使用了h5的文件压缩格式，并提供了一些<a href="https://github.com/tbertinmahieux/MSongsDB">code</a>用于读这种文件。</p><span id="more"></span><p>每首歌对应一个文件，字段包括歌曲的方方面面，如 <code>artist_mbid</code> ， <code>artist_name</code> ， <code>title</code> ， <code>tempo</code> 等等，所有字段<a href="https://labrosa.ee.columbia.edu/millionsong/pages/example-track-description">在这里列出</a>。<br>路径是奇怪的，Q&amp;A中解释说，实在无法把所有文件都放到同一个目录下，目录的组织方式为：<br>某首歌曲所在位置为它的The Echo Nest track IDs的第三、第四、第五位形成的层级目录，比如 <code>MillionSong/data/A/D/H/TRADHRX12903CD3866.h5</code> 。</p><p>此外，在MSD的基础上，社区还贡献了不少补充数据集，方便对MSD做各方面的研究。在首页可以很容易找到它们。</p><ul><li>  <a href="https://labrosa.ee.columbia.edu/millionsong/secondhand">The SecondHandSongs Dataset</a>: 一些歌曲被翻唱的信息，以及<a href="https://secondhandsongs.com/">Second Hand</a>网站对各翻唱的performance值。</li><li>  <a href="https://labrosa.ee.columbia.edu/millionsong/musixmatch">The musiXmatch Dataset</a>: 以bag-of-words的形式提供了MSD中77%数量歌曲的歌词数据。</li><li>  <a href="https://labrosa.ee.columbia.edu/millionsong/lastfm">The Last.fm Dataset</a>: <a href="#org2ba734e">见下文</a></li><li>  <a href="https://labrosa.ee.columbia.edu/millionsong/tasteprofile">The Echo Nest Taste Profile Subset</a>: Echo Nest提供了可以与MSD关联的user-song-play count数据集，包含100万user，4800万播放记录。</li><li>  <a href="https://labrosa.ee.columbia.edu/millionsong/thisismyjam">thisismyjam-to-MSD mapping</a>: 音乐社交网站<a href="https://www.thisismyjam.com/">thisisjam</a>的用户数据以及到MSD的关联。</li><li>  <a href="http://www.tagtraum.com/msd_genre_datasets.html">tagtraum genre annotations</a>: music genre标注。</li><li>  <a href="http://www.ifs.tuwien.ac.at/mir/msd/">Top MAGD dataset</a>: music genre标注。</li></ul><h1 id="Lastfm数据集"><a href="#Lastfm数据集" class="headerlink" title="Lastfm数据集"></a>Lastfm数据集</h1><p><a href="https://www.last.fm/">last.fm</a>是一家英国的网络电台和音乐社区，其向发开者提供了<a href="https://www.last.fm/api">丰富的API</a>，于是有很多机构或个人通过调用这些API来生成一些数据集。</p><h2 id="1K-users-user-full-listening-history"><a href="#1K-users-user-full-listening-history" class="headerlink" title="1K users (user full listening history)"></a>1K users (user full listening history)</h2><p>《推荐系统实战》2.1节介绍到了<a href="https://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-1K.html">此数据集</a>，作为有上下文信息的隐性反馈数据集的代表。<br>它有两个文件，听歌记录与用户信息。<br>前者为近1000位听众至2009年5月5日为止的所有音乐播放记录与播放时间，以及音乐的title、artist name、musicbrain id等信息。<br>后者则记录了所有听众的性别、年龄、国家、注册时间的信息。<br>其中听歌记录的统计数字如下：</p><ul><li>  Total Lines:           19,150,868</li><li>  Unique Users:                 992</li><li>  Artists with MBID:        107,528</li><li>  Artists without MBDID:     69,420</li></ul><h2 id="360K-users-user-top-artists"><a href="#360K-users-user-top-artists" class="headerlink" title="360K users (user top artists)"></a>360K users (user top artists)</h2><p>与1K数据集一起出现的还有360K users数据集。<br>包含user-artist关系信息以及用户信息。<br>用户信息与1K相同，不过数据量来到了360K，user-artist关系文件的一行为某user听某乐队的次数。<br>user-artist文件的统计数据如下：</p><ul><li>  Total Lines:           17,559,530</li><li>  Unique Users:             359,347</li><li>  Artists with MBID:        186,642</li><li>  Artists without MBID:     107,373</li></ul><h2 id="HetRec-2011"><a href="#HetRec-2011" class="headerlink" title="HetRec 2011"></a>HetRec 2011</h2><p>这是2011年HetRec会议发布的<a href="https://grouplens.org/datasets/hetrec-2011/">从Last.fm获取的数据集</a>。<br>与上两例不同的是它包含有社会好友关系，标签信息。其中文件数目比较多，但各文件列很较少，其中是很明显简单的关联关系，不再赘述。<br>统计数据如下：</p><ul><li>  1892 users</li><li>  17632 artists</li><li>  12717 好友关系</li><li>  92834 user-listened artist relations</li><li>  11946 tags</li><li>  186479 tag assignments (tas), i.e. tuples [user, tag, artist]</li></ul><h2 id="MSD’s-Lastfm"><a href="#MSD’s-Lastfm" class="headerlink" title="MSD’s Lastfm"></a>MSD’s Lastfm<a id="org2ba734e"></a></h2><p>在MSD的首页可以看到此来自Lastfm的数据集（又一个，真的很容易搞乱。），它作为MSD的补充信息，可与其id直接关联。<br>数据量较大，是下面的样子：</p><ul><li>  943,347 matched tracks MSD &lt;-&gt; Last.fm</li><li>  505,216 tracks with at least one tag</li><li>  584,897 tracks with at least one similar track</li><li>  522,366 unique tags</li><li>  8,598,630 (track - tag) pairs</li><li>  56,506,688 (track - similar track) pairs</li></ul><p>与MSD一样的奇怪的目录结构，每个歌曲对应一个json文件，长这个样子：<br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/8cf5b699c1faf5c5922fabe47f42cded.jpg" alt="img"></p><p>文件名是 TRAAAAW128F429D538.json 这样的编码可与MSD的某首歌关联起来，图中提供了基本的歌曲、作者信息、标签。<br>比较独特的是还有Lastfm直接提供的与此歌曲相似的歌曲列表以及相似度值。</p><h1 id="其他数据集"><a href="#其他数据集" class="headerlink" title="其他数据集"></a>其他数据集</h1><ul><li>  <a href="https://arxiv.org/abs/1612.01840">fma</a>: music audio大型数据集，917 GiB and 343 days of Creative Commons-licensed audio from 106,574 tracks from 16,341 artists and 14,854 albums, arranged in a hierarchical taxonomy of 161 genres。</li><li>  <a href="https://www.kaggle.com/nolanbconaway/pitchfork-data/home">Pitchfork reviews</a>: <a href="https://pitchfork.com/">Pitchfork</a>是一家在线音乐杂志，有人爬取了自1999年以来的18000份音乐评论文章放到Kaggle上用于分析和学习。 格式为sqlite文件，主要提供信息为文章的id、标题、artist、文章链接、评分、作者、发布时间等。</li><li>  <a href="https://github.com/walkerkq/musiclyrics">50 Years of Pop Music Lyrics</a>: 1964到2015Billboard每年的Year-End Hot100歌曲的歌词。</li><li>  <a href="https://www.kaggle.com/gyani95/380000-lyrics-from-metrolyrics/home">MetroLyrics</a>: 从MetroLyrics爬取的38万首歌词，csv格式，字段有song title，artist，genre，lyric。</li><li>  <a href="https://www.kaggle.com/c/kkbox-music-recommendation-challenge">kkbox</a>: WSDM 2018比赛使用的数据集，<a href="https://www.kkbox.com/intl/">kkbox</a>作为一家亚洲音乐服务商，提供了很多亚洲歌曲信息，这点是以上其他所不具有的。</li><li>  <a href="https://www.kaggle.com/geomack/spotifyclassification/home">Spotify Song Attributes</a>: 作者调用spotify的api获取了2017首歌的数据并尝试获取训练一个模型来预测自己是否喜欢一首歌。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>根据一些官方或民间的API，可以根据自己的需求生成自定义的数据集。</p><ul><li><a href="https://www.last.fm/api">last.fm API</a></li><li><a href="http://developer.echonest.com/">echonest API</a></li><li><a href="https://developer.spotify.com/documentation/web-api/">Spotify API</a></li><li><a href="http://static.echonest.com/enspex/">The Echo Nest / Spotify APIs work together</a></li><li><a href="https://musicbrainz.org/doc/Developer_Resources">music brain API</a></li><li><a href="https://github.com/yanunon/NeteaseCloudMusic/wiki/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90API%E5%88%86%E6%9E%90">云音乐API</a></li><li><a href="https://www.quora.com/What-is-the-best-most-complete-API-or-database-for-searching-music-data">Quora: What is the best, most complete API or database for searching music data?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;接下来会研究一下音乐推荐系统，需要数据来进行算法及工程代码的演示，遂汇总一下网上开源的音乐数据集。&lt;/p&gt;
&lt;h1 id=&quot;Million-Song-Dataset&quot;&gt;&lt;a href=&quot;#Million-Song-Dataset&quot; class=&quot;headerlink&quot; title=&quot;Million Song Dataset&quot;&gt;&lt;/a&gt;Million Song Dataset&lt;/h1&gt;&lt;p&gt;说到音乐数据集第一位肯定是MSD，它包含了100万首歌曲的信息，总量有280GB大小。由于数据量的确较大，它使用了h5的文件压缩格式，并提供了一些&lt;a href=&quot;https://github.com/tbertinmahieux/MSongsDB&quot;&gt;code&lt;/a&gt;用于读这种文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="摇滚乐" scheme="http://guerbai.github.io/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
    <category term="推荐系统" scheme="http://guerbai.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用 Karabiner 改善 Poker 键盘体验</title>
    <link href="http://guerbai.github.io/2018/10/23/anli-karabiner/"/>
    <id>http://guerbai.github.io/2018/10/23/anli-karabiner/</id>
    <published>2018-10-23T04:00:00.000Z</published>
    <updated>2021-11-06T08:53:26.432Z</updated>
    
    <content type="html"><![CDATA[<p>Poker 键盘以其小巧、精致、可编程深受广大用户的喜爱，更关键的是，它颜值还很高。时常作为 Mac 的外接键盘日常使用。  </p><p><img src="https://cdn.sspai.com/2018/10/25/3a6b07ce1f3f2a8b3928fa269958cd01.png"></p><span id="more"></span><p>然而往往小巧与极客的事物便意味着会有一些操作方式让使用者不够习惯，因而会产生一些痛点，比如没有直接的方向键等等。  </p><p>网上有一些文章介绍了 Poker 底部开关的设置，以及 Mac 基本的几个功能键修改功能，笔者进行过尝试，然而其修改过于基础，依然不够好用。  </p><p>本篇介绍了笔者使用 Mac 上的改键软件 <a href="https://pqrs.org/osx/karabiner/">Karabiner</a> 对 Poker 键盘进行自定义化设置，从而优化其作为 Mac 外接键盘体验的具体实施方案。  </p><p>通过本文所举的 case，掌握了 Karabiner 的使用方法之后，便可以对任意键盘进行任意程度的自定义设置了，可谓一通百通，解放你的手指，在 Mac 上驰骋，效率提升一个数量级。</p><h2 id="功能键的调整"><a href="#功能键的调整" class="headerlink" title="功能键的调整"></a>功能键的调整</h2><p>功能键一般要左手去按，Poker 左下角的功能键布局如图所示：  </p><p><img src="https://cdn.sspai.com/2018/10/25/0778e093a41654521ba52d87351b1950.png"></p><h3 id="调整左-Ctrl-与左-Command"><a href="#调整左-Ctrl-与左-Command" class="headerlink" title="调整左 Ctrl 与左 Command"></a>调整左 Ctrl 与左 Command</h3><p>位于键盘最左下角的键按键方式是使用 <strong>左手掌外侧</strong> 按下，这样不需要移动扭曲小指或是移动手在键盘上的位置，可减少对手指的伤害，非常自然。  </p><p>然而，Poker 最左下角的键是 Ctrl，而在 Mac 系统上，最常用的 <em>保存、复制、粘贴</em> 三个操作的按键却是 <code>⌘Command + S \ C \ V</code> 来实现的。  </p><p>左 Command 键位于左 Ctrl 右边，依然使用左手掌外侧来按，但这就不那么自然了，需要左手下部往右侧稍稍移动一个键位来够到。  </p><p>根据频次来讲，在 Mac 上，使用 <code>Ctrl + Key</code> 组合键的常用操作不能说没有，但远比不上上述保存、复制、粘贴三兄弟，因此，果断将二者调换位置。  </p><h3 id="将-Capslock-改为左-Option"><a href="#将-Capslock-改为左-Option" class="headerlink" title="将 Capslock 改为左 Option"></a>将 Capslock 改为左 Option</h3><p>笔者没有使用 Capslock 的需求，大写字母通过 <code>⇧Shift + A</code> 这样的方式来实现，完全可以将它替换为更常用的按键。  </p><p>在 Mac 上，使用 Option 的频次较多的操作主要有两个，唤起 Alfred 用 <code>⌥Option + Space</code> 的快捷键，以及在 Emacs 中运行函数用 <code>⌥Option + X</code> 的快捷键。  </p><p>而在 Poker 上左 Option 位于左 Command 的右侧，左手掌移一个键已经够难受了，移两个键更是不可取，若使用大拇指去往里勾，笔者认为和使用小指去勾 Ctrl 一样，长久而言对手指有损伤，故果断将 Capslock 改为左 Option，这样对于上述所提到的两个操作都方便与自然了许多，使用小指从 A 移到 Capslock 是很轻松的事。  </p><p><img src="https://cdn.sspai.com/2018/10/25/fdd15e5d930ef73ccb8bc62515ac2e23.png"></p><h2 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h2><h3 id="方向键的改进"><a href="#方向键的改进" class="headerlink" title="方向键的改进"></a>方向键的改进</h3><p>Poker 并无自带的方向键，然而就算自带方向键，将右手抬起来去按这个操作还是蛮糟心的，况且还容易按错。  </p><p>Poker的原生方案是 <code>Fn + W \ A \ S \ D</code>，这当然很极客了，然而这却也是笔者使用 Karabiner 的直接原因。  </p><p>问题在于这个操作需要两个手，而通过自定义 Karabiner 的 Complex Modifications，可以将 <code>Fn + W \ A \ S \ D</code> 这种方案改为 <code>⌥Option + W \ A \ S \ D</code>，加上之前将 Capslock 改为了 Option，则仅使用左手便可以使用方向键。  </p><p>Complex Modifications 是 Karabiner 的一个进阶功能，通过 json 配置的方式，可以实现任意的键盘行为方式的自定义，绝对超出你的想象。  </p><p>官方提供了 <a href="https://pqrs.org/osx/karabiner/complex_modifications/">一些例子</a>，比如将 Capslock 进行修改，当它与其他键一起使用时发挥 Ctrl 的功能，当它单独被按下时，发挥 Esc 的功能。  </p><p>这些例子中并没有更改 Poker 方向键的 case，然而通过参考其例子的 json 配置方式，完全可以实现自己想要的任何行为。  </p><p>其配置文件在 <code>~/.config/karabiner/assets/complex_modifications</code> 目录，新建<code>guerbai-keymap.json</code> 文件，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;poker arrow keys&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;holing left alt and asdw use arrow keys.&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;manipulators&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;basic&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;from&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;modifiers&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;mandatory&quot;</span>: [<span class="string">&quot;left_Option&quot;</span>]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;Optional&quot;</span>: [<span class="string">&quot;any&quot;</span>]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">&quot;to&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;left_arrow&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只举了将 <code>⌥Option + A</code> 改为左方向键的配置，配置的 key 是自解释的，即当 A 被按下时，若此时 Option 也是被按下的，则实现 <code>left_arrow</code> 的行为，很易懂就不再多解释，同样的格式在 rules 里来四份分别对应 <code>W \ A \ S \ D</code> 到四个方向键即可。</p><h3 id="Backspace-与-Enter"><a href="#Backspace-与-Enter" class="headerlink" title="Backspace 与 Enter"></a>Backspace 与 Enter</h3><p>在使用 Evernote 等软件编辑文字或浏览网页时，通常是右手握鼠标，左手在键盘，这个过程中通常会遇到要按 Backspace 或 Enter 的情况，这时便不得不将右手从鼠标拿开，去按退格或回车，再放回到鼠标上，极其不爽。  </p><p>在上述姿势下，自然可以想到若是左手可以直接按到 Backspace 与 Enter 的话便会方便许多。  </p><p>这里的配置与方向键的改进很像，笔者采取的策略是，当 Option（已被改到 Capslock）被单独按下时，呈现出 Backspace 的作用，而 <code>Command（已被改为左 Ctrl）+ Space</code> 则呈现为 Enter。配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;poker arrow keys&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;basic&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;from&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;spacebar&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;modifiers&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;mandatory&quot;</span>: [<span class="string">&quot;left_Command&quot;</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;Optional&quot;</span>: [<span class="string">&quot;any&quot;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;to&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;return_or_Enter&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;basic&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;from&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;left_Option&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;modifiers&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;Optional&quot;</span>: [<span class="string">&quot;any&quot;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;to&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;left_Option&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;to_if_alone&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;delete_or_Backspace&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左右切换全屏程序"><a href="#左右切换全屏程序" class="headerlink" title="左右切换全屏程序"></a>左右切换全屏程序</h2><p>Mac 触控板的四指横扫是切换全屏程序的利器，而外接键盘却并不那么方便。<code>⌘Command + Tab</code> 自然是一种方案，然而却不够精确，同时要反向切 <code>⌘Command + ⇧Shift + Tab</code> 是极难按的，笔者通常更喜欢使用 <code>⌘Command + 方向键</code> 来进行切换。  </p><p>在未改造方向键时，这个操作在Poker上简直麻烦，需要左手掌外侧压住 Command，右手掌外侧压住 Fn，左手指按 A 或 D，然而上述改方向键的方案并不能直接与 Command 配合来进行切换，因为它仅指定了 mandatory 为 Command，还需要进一步改造。  </p><p>笔者的设计是将这个操作改为左手一只手可以进行，使用 <code>⌘Command + ⌥Option + A \ D</code>  来进行切换，这样比如在网页上看到一段话，可以右手用鼠标进行复制，左手切到旁边的 Evernote，右手鼠标点击选择笔记，左手粘贴，不需要做任何大幅度的移动。  </p><p>在上述 Karabiner 配置文件夹下再建一个文件命名为 <code>guerbai-change-application.json</code>，内容输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;change application&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;change application use poker&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;manipulators&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;basic&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;from&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;modifiers&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;mandatory&quot;</span>: [</span><br><span class="line">                                <span class="string">&quot;left_Option&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;left_Command&quot;</span></span><br><span class="line">                            ]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;Optional&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;any&quot;</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">&quot;to&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;key_code&quot;</span>: <span class="string">&quot;left_arrow&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;modifiers&quot;</span>: [</span><br><span class="line">                                <span class="string">&quot;left_Command&quot;</span></span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到将 mandatory 改为 Option 和 Command，这样就可以仅使用左手方便地切换程序了。</p><p>设置界面如下图：</p><p><img src="https://cdn.sspai.com/2018/10/25/e0b3cf4c91b4d3abbe1195eb981dad5e.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>相信经过上述示例，已经可以体会到 Karabiner 的强大了，通过简单而又强大的 json 配置，来实现任意键盘上任意自己想要的行为，简直不要太爽。  </p><p><a href="https://gist.github.com/guerbai/2d3d98f6409452d5951ac4aa0e735b2f">这里</a> 是上述配置的完整版，放到配置文件夹下后，使用 Complex Modifications 的 「Add rule」 添加文件使其生效即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Poker 键盘以其小巧、精致、可编程深受广大用户的喜爱，更关键的是，它颜值还很高。时常作为 Mac 的外接键盘日常使用。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2018/10/25/3a6b07ce1f3f2a8b3928fa269958cd01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="软件" scheme="http://guerbai.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="折腾" scheme="http://guerbai.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于Java单例模式需要知道的</title>
    <link href="http://guerbai.github.io/2018/10/23/java-singleton/"/>
    <id>http://guerbai.github.io/2018/10/23/java-singleton/</id>
    <published>2018-10-23T02:19:00.000Z</published>
    <updated>2021-11-06T08:53:26.435Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式，甚至是所有的二十几种设计模式，已经是一个被说得快要烂掉的话题了。<br>笔者也自觉网上太多类似内容未免有些聒噪，然而最近在看《<a href="https://book.douban.com/subject/2130190/">Java编程思想</a>》时，意识到该书之意味无穷有很大一部分原因在于将各色设计模式整合于各处，在描述讲解Java语言的设计时，各种成熟的设计便在例子与解读中缓缓流淌而出。  </p><p>诚然，要论设计模式，若用Python来举例，总不免会感觉一些例子着实有些迁强，而Java才是设计模式生长的沃土，在很多内置库中便采用了这些设计与实现。  </p><span id="more"></span><p>故笔者意欲总结、学习一下在该书、Java内置语言实现方面所用到的设计模式，以及采用这种设计的思考，并不同于网上随处可见模式讲解以及代码罗列。<br>遂有些篇。</p><h1 id="Singleton-in-lt-Thinking-in-Java-gt"><a href="#Singleton-in-lt-Thinking-in-Java-gt" class="headerlink" title="Singleton in &lt;Thinking in Java&gt;"></a>Singleton in <code>&lt;Thinking in Java&gt;</code></h1><p>作者在第六章 <em>访问控制权限</em> 的 <em>类的访问权限</em> 中即举了一个 <em>单例模式</em> 的例子，此时前面的章节只讲了操作符、 <code>if-else</code> 与构造器的内容，连函数都没开讲，甚至在代码例子中设计到 <code>public static Soup1 makeSoup()</code> 这样的语句也要跟读者补充一下Soup1是返回值的类型的知识。<br>那作者何故要在此节的例子中直接引入设计模式这样相对而言更为高深的话题呢？这对于作者讲解类的访问权限有什么帮助呢？</p><p>例子很简单，诸君想必已见过无数次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Soup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup ps1 = <span class="keyword">new</span> Soup();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个常见的单例写法，看到代码之后很容易明悉作者的意图，正是由于该类的构造函数被设定为private，才保证其不能被客户端任意实例化，只能通过类设计者提供的唯一入口来获取此实例，保证了单例的唯一性。  </p><p>此时反观Python，由于其并未具有类似Java语言private提供的这种保证，其单例模式的实现看起来更像是一种hack，需要对Python有一些更深入的理解才可领悟，对比如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然，就两种版本而言，Python的实现相较于Java需要对语言本身更为深入的理解。<br>要看懂Python版本的单例模式，你需要了解到Python <code>__init__</code> 与 <code>__new__</code> 的区别， <code>*args</code> 与 <code>**kw</code> 这种写法的意思以及继承的有关知识。  </p><p>本书后文 <em>类型信息</em> 一章 <em>空对象</em> 一节，给出了一个使用单例模式的典型场景。<br>使用一个static final的单例来表示系统中的空对象，比如一个不存在的Person，可以保证该对象不被改变，从而给系统带来一个有效的对象，并且可以减少和优化四处判断空指针的dirty code。</p><h1 id="几种写法的考量"><a href="#几种写法的考量" class="headerlink" title="几种写法的考量"></a>几种写法的考量</h1><p>在单例模式的实现上也有一定的差异，这其中设计到一些效率与线程安全性方面的考量，并不是“茴香豆”的茴有几种写法一般的炫技取乐。</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>在上面关于Soup的例子中，可以看出在类被加载时其单例便已经被构造成功了。<br>这就好比饭店煮了一碗汤，材料与能源直接消耗掉，却不一定有顾客去真的喝这碗汤，这便形成了一种浪费。<br>在大型程序中，有些对象的构造的确是要消耗比较大的资源的，等到有顾客需要时，才去构造，会是一种行之有效的优化。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Soup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup ps1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ps1 = <span class="keyword">new</span> Soup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此便是一种优化了。</p><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>然而，上面的例子是有隐患的，它并不是线程安全的，由于存在<a href="https://github.com/guerbai/it-does-works">竞态条件</a>的问题，以上的写法在多线程环境下，只是 <strong>有可能</strong> 运行正确，实际上它无法保证该类只有一个实例。<br>其实要消除这种隐患很简单，将access方法标记为synchronized即可。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Soup <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ps1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ps1 = <span class="keyword">new</span> Soup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ps1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，对线程安全性的保证往往是有性能代价的，上述写法的synchronized实际上只是为了保护ps1的确为null时的情况，而当其已被实例化之后多个线程再去access时，也会受到一定的性能影响，而此时synchronized其实是不再需要了的。  </p><p>为解决此问题，又有一些其他的写法，比如 <em>内部类</em> 、 <em>双重检查</em> 、 <em>enum</em> 等，会引入Java语言其他的细节，此处不再多表。</p><h1 id="Java语言设计中的单例模式"><a href="#Java语言设计中的单例模式" class="headerlink" title="Java语言设计中的单例模式"></a>Java语言设计中的单例模式</h1><p>在Java语言自身的设计实现中，也随便可见单例模式的身影，现举例如下。</p><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runtime采用了最初的Soup写法，毕竟它是Java运行时必要的对象，也没有延迟加载的必要，直接在类加载时实例化，也不会遭遇线程安全性的问题，很干净且合理。</p><h2 id="Desktop"><a href="#Desktop" class="headerlink" title="Desktop"></a>Desktop</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchronizedsynchronized Desktop <span class="title">getDesktop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GraphicsEnvironment.isHeadless()) <span class="keyword">throw</span> <span class="keyword">new</span> HeadlessException();</span><br><span class="line">        <span class="keyword">if</span> (!Desktop.isDesktopSupported()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Desktop API is not &quot;</span> +</span><br><span class="line">                                                    <span class="string">&quot;supported on the current platform&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sun.awt.AppContext context = sun.awt.AppContext.getAppContext();</span><br><span class="line">        Desktop desktop = (Desktop)context.get(Desktop.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desktop == <span class="keyword">null</span>) &#123;</span><br><span class="line">            desktop = <span class="keyword">new</span> Desktop();</span><br><span class="line">            context.put(Desktop.class, desktop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> desktop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java图型化界面中，Desktop采用了线程安全的延迟加载，这在很大程序上依赖于该类的特性，Desktop是否被支持，包括App的上下文都是要考虑的因素，最后才去创建实例。<br>在这里，并未看到为了synchronized造成的一点性能影响而采用其他写法。</p><h2 id="System-SecurityManager"><a href="#System-SecurityManager" class="headerlink" title="System.SecurityManager"></a>System.SecurityManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SecurityManager.class) &#123;</span><br><span class="line">            SecurityManager sm = System.getSecurityManager();</span><br><span class="line">            <span class="comment">/* whatever code block */</span></span><br><span class="line">            initialized = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SecurityManager security = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> security;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的确是很特立独行的一种写法，可以看到，两个类相互配合共同实现了SecurityManager的单例，并且在System中并未在get函数或是类加载时进行初始化。<br>SecurityManager的单例并不是其自身的一个属性，而是在System中，同时，全局唯一访问入口也在System的getSecurityManager方法。  在程序设计上让System持有其他类的实例，并且保证了它是单例的。  </p><p>可以注意到，System中该属性使用了volatile修饰，避免多纯种之间的可见性问题，这是为了满足security可以为null的设计需要，这种灵活性是上面的其他例子所没有的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过思考《Java编程思想》作者介绍单例模式的思路，以及一些写法的改进与讨论，再加上最后Java语言本身的设计实现上的例子，对单例模式可以有更进一步的了解和对实际应用的思考。<br>单例模式可以实现得很简单，也可以实现得较为复杂，其间的一些取舍与优劣还需诸君在实际应用中考虑具体情况，选择最合适的那一种。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li> <a href="https://book.douban.com/subject/2130190/">Thinking in Java</a></li><li> <a href="https://docs.oracle.com/javase/8/docs/">Java8 document</a></li><li> <a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a></li><li> <a href="https://zhuanlan.zhihu.com/p/31046230">线程安全的单例类</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;单例模式，甚至是所有的二十几种设计模式，已经是一个被说得快要烂掉的话题了。&lt;br&gt;笔者也自觉网上太多类似内容未免有些聒噪，然而最近在看《&lt;a href=&quot;https://book.douban.com/subject/2130190/&quot;&gt;Java编程思想&lt;/a&gt;》时，意识到该书之意味无穷有很大一部分原因在于将各色设计模式整合于各处，在描述讲解Java语言的设计时，各种成熟的设计便在例子与解读中缓缓流淌而出。  &lt;/p&gt;
&lt;p&gt;诚然，要论设计模式，若用Python来举例，总不免会感觉一些例子着实有些迁强，而Java才是设计模式生长的沃土，在很多内置库中便采用了这些设计与实现。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="读书" scheme="http://guerbai.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="java" scheme="http://guerbai.github.io/tags/java/"/>
    
    <category term="源码阅读" scheme="http://guerbai.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>你见过Python的GIL吗</title>
    <link href="http://guerbai.github.io/2018/10/19/python-gil-exist/"/>
    <id>http://guerbai.github.io/2018/10/19/python-gil-exist/</id>
    <published>2018-10-19T15:46:00.000Z</published>
    <updated>2021-11-06T08:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>GIL是<strong>Global Interpreter Lock</strong>的简称，翻译为中文是<strong>全局解释器锁</strong>，维基百科的解释为：</p><blockquote><p>全局解释器锁是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。</p></blockquote><span id="more"></span><h1 id="关于Python多线程与GIL的思考"><a href="#关于Python多线程与GIL的思考" class="headerlink" title="关于Python多线程与GIL的思考"></a>关于Python多线程与GIL的思考</h1><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>学过Python的人大都知道这个解释性语言最通用的实现(CPython)采用了GIL的方式，因此在网上可以看到一些言论说“Python因为有GIL存在，多线程就算了，还是多进程吧”。<br>可这并不符合使用Python编程的实际体验，的确会让人产生一些疑惑。<br>Python有其自带的多线程模块，而且著名的爬虫框架<a href="https://github.com/scrapy/scrapy">scrapy</a>可以同时爬多个网站，感觉上其并没有受到GIL的限制。<br>与Java对比的话，Java也支持多线程也可以写爬虫，而Java并没有GIL，这与Python看起来好像没有什么区别，那么GIL到底有没有发挥作用呢？   </p><p>能否使用Java和Python分别写一段语义上一样的代码，通过两段程序的output有着明显的不同来证明GIL的确存在并且起了一定的作用呢？<br>要做这个事情首先要进行理论上的更进一步探索，才能进行代码的实现与output的设计。</p><h2 id="关于并发的知识铺垫"><a href="#关于并发的知识铺垫" class="headerlink" title="关于并发的知识铺垫"></a>关于并发的知识铺垫</h2><p>&lt;<a href="https://book.douban.com/subject/26912767/">CSAPP</a>&gt;上提到了三种不同层面的 <strong>并发编程技术</strong>，分别为：</p><ol><li> 进程级别的并发；</li><li> I/O多路复用；</li><li> 线程级别的并发。</li></ol><p>显然此篇的讨论应该归到第三种类型。</p><p>接下来，还要明确另一对容易搞错的概念， <strong>并发</strong> 与 <strong>并行</strong> 。<br><strong>并发</strong> 指的是逻辑控制流在时间上的重叠，而 <strong>并行</strong> 则是指对多核CPU的利用。<br>并行只是并发的一个真子集，有种说法是“并发是基于逻辑上的同时发生，而并行是基于物理上的同时发生”。<br>所以，在只有一个CPU的机器上也可以运行并发程序，却不能运行并行程序。</p><h2 id="使用加速比证明GIL存在的假设"><a href="#使用加速比证明GIL存在的假设" class="headerlink" title="使用加速比证明GIL存在的假设"></a>使用加速比证明GIL存在的假设</h2><p>根据以上关于并发与并行的基本知识，Python与Java在并发程序上的本质区别便可以得知。<br>即，因为有GIL的存在，Python无法利用到多核处理器的并行性，但依然可以编写除此之外的并发程序，并获得效率提升。而Java则无此限制。  </p><p>CSAPP中提到了对于并行程序性能的衡量标准: <strong>加速比</strong> 。</p><div align=center><p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668d04bf3c07dec?w=228&h=108&f=png&s=4216"></p></div>上述公式中，Sp称为加速比，其中p是处理器核的数量，Tp是指在p个核上程序的执行时间，当T1是程序顺序执行版本的执行时间时，Sp称为绝对加速比，而当Sp为程序并行版本在一个核上的执行时间时，Sp称为相对加速比。  <p>所以，可以使用绝对加速比来证明GIL的存在。<br>预期是，写一段无IO的计算密集性任务，分别交给Python与Java的一个(顺序执行)、多个线程(并行版本)去运行，算出各自的加速比，如果Python版本加速比小于1，而Java版本的加速比在计算机核心数左右，则说明是GIL起了作用，导致Python程序无法发挥多核的并行性。</p><h1 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h1><p>依然使用书中的例子: 做一个加法任务，从0加到0x7fffffff求和，通过设置线程数n，将数字加和任务平均拆分为n份，给到各线程做自己的一份，最后将子任务的和再加和求得最后的结果。<br>那么当n等于1时，即为顺序版本，n大于1时则为并行版本。<br>书中代码使用C语言实现，此处分别改写为Python与Java两个版本。</p><p>入口为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    thread_num1 = <span class="number">1</span></span><br><span class="line">    thread_num2 = <span class="number">2</span></span><br><span class="line">    thread_num4 = <span class="number">4</span></span><br><span class="line">    thread_num8 = <span class="number">8</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;sum_task with thread_num1 cost time: &quot;</span> + <span class="built_in">str</span>(measure_time_cost(thread_num1)) + <span class="string">&quot;s in Python version.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;sum_task with thread_num2 cost time: &quot;</span> + <span class="built_in">str</span>(measure_time_cost(thread_num2)) + <span class="string">&quot;s in Python version.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;sum_task with thread_num4 cost time: &quot;</span> + <span class="built_in">str</span>(measure_time_cost(thread_num4)) + <span class="string">&quot;s in Python version.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;sum_task with thread_num8 cost time: &quot;</span> + <span class="built_in">str</span>(measure_time_cost(thread_num4)) + <span class="string">&quot;s in Python version.&quot;</span>)</span><br></pre></td></tr></table></figure><p>分别用尝试1，2，4，8个线程下运行结果，<code>measure_time_cost</code> 主要用来创建目标数量的线程，给各线程分配自己的计算任务，然后等待各线程全部返回，再加和，同时返回耗时，该函数实现为：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure_time_cost</span>(<span class="params">thread_nums</span>):</span></span><br><span class="line">    nums = <span class="number">99999999</span> <span class="comment"># Python加到0x7fffffff要太久，改一个小一点的值。</span></span><br><span class="line">    num_per_thread = <span class="built_in">int</span>((nums + <span class="number">1</span>) / thread_nums)</span><br><span class="line">    thread_list = [<span class="literal">None</span>] * thread_nums</span><br><span class="line">    task_list = [<span class="literal">None</span>] * thread_nums</span><br><span class="line">    start_at = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(thread_nums):</span><br><span class="line">        ct = SumTask()</span><br><span class="line">        thread_list[i] = threading.Thread(target=ct.run, args=(i, num_per_thread))</span><br><span class="line">        thread_list[i].start()</span><br><span class="line">        task_list[i] = ct</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(thread_nums):</span><br><span class="line">        thread_list[i].join()</span><br><span class="line">    end_at = time.time()</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(thread_nums):</span><br><span class="line">        result += task_list[i].get_result()</span><br><span class="line">    <span class="built_in">print</span> (result)</span><br><span class="line">    <span class="keyword">return</span> end_at - start_at</span><br></pre></td></tr></table></figure><p>用到的SumTask就是一个简单的类用来处理返回值，不想去用queue，全局变量什么的。  </p><p>由于笔者的mac只有两核，无法看到4核、8核等更明显的效果，Python版本的程序跑下来结果为：  </p><div align=center><p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668d04bf3b5a99a?w=1058&h=372&f=png&s=66487"></p></div><p>而Java版本的相同实现，跑下来的结果为：  </p><div align=center><p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668d04bf3aebe77?w=697&h=371&f=png&s=64233"></p></div><p>由于电脑核少，故主要看2核情况的对比，Python版本使用2核并没有得到明显的增速，加速比小于1。而Java版则差不多为2，发挥到了多核的效用，提高了计算密集性任务的效率。<br>随着线程数的增加，由于没有那么多核，线程切换的副作用体现了出来，后面时间会增加到比单线程还多。  </p><p>之后，在<a href="https://www.zhihu.com/question/296546864/answer/501359602">知乎</a>上有网友利用8核电脑做了验证，依然与预期相符，Java的最大加速比为0.701/0.168=4.17，而Python的加速比均小于0.5。</p><div align=center><p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668d04bf3c7b9a5?w=1278&h=692&f=png&s=583611"></p></div><p>Java代码就是Executor提交任务，然后通过继承Callable利用Future得到结果。<br>完整版代码在<a href="https://github.com/guerbai/it-does-works">这里</a>，直接复制进code runner跑就可以看到结果，很方便。</p><p>这，可能是很多人第一次感受到GIL的存在吧~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GIL是&lt;strong&gt;Global Interpreter Lock&lt;/strong&gt;的简称，翻译为中文是&lt;strong&gt;全局解释器锁&lt;/strong&gt;，维基百科的解释为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全局解释器锁是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://guerbai.github.io/tags/python/"/>
    
    <category term="并发" scheme="http://guerbai.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈下python微服务中的序列化场景</title>
    <link href="http://guerbai.github.io/2018/08/19/python-serialization-scenes/"/>
    <id>http://guerbai.github.io/2018/08/19/python-serialization-scenes/</id>
    <published>2018-08-19T14:34:00.000Z</published>
    <updated>2021-11-06T08:53:26.438Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://guerbai.github.io/2018/08/19/check-param/">上一篇文章</a>中说到了验参，现在接着说另一个微服务中的工程性问题，序列化。<br>作为编写业务的程序员，常被戏称为CRUD程序员，会增删改查，给个if else给个for就能混碗饭吃。此话倒不假。<br>在微服务体系下，工作中有时会接触多个项目，各个service与各个gateway，由于维护人员的不同，虽然都是做CRUD的工作，但项目结构与写法却不尽相同。</p><span id="more"></span><p>这让我回想起刚参加工作时加入一家很小的创业公司，一个简单的单体应用，只有一层，flask的http request进来直接去操作DB，操作sqlalchemy的session，没有任何的抽象，可以说没有任何可以复用的业务代码，每个函数进来都是全新的世界，要开始重新探索，极其丑陋。（甚至可以开玩笑地说，这样有了bug可以将bug只控制在那一个函数以内，不会存在迁一发而动全身的风险。。。）</p><p>所以我觉得，将Python微服务中的常见业务代码做到规范化并且尽可能的优雅其实是并不容易的，Python灵活归灵活，但太灵活却容易写出太飘的代码，无法与Java的工程性相提并论。</p><p>代码结构层面其实也不用多说，上篇文章中提到过，handler，service，model三层结构，handler进行验参后调service，service可以调service和model，model不可以互相调，验参也是一个比较重要的环节。<br>这篇来说一下序列化问题，总结一下一个最简单的由前端发起的http请求到gateway再由thrift rpc到service再到db总共要经历多少次序列化和反序列化，以及对Python序列化库marshmallow的应用实践，搞清楚一个简单的CRUD的请求中间到底经过了多少层的转换以及每一次的转换是为了什么。</p><hr><p>其实就序列化这个描述本身而言，并没有说清楚从哪种类型到哪种类型是序列化，从而在各种场景下都会用到这个词，常常会让人感到混淆。<br>比如，Python有个pickle库，众所周知是用于将任意Python对象以文件的形式存入磁盘，它有的序列化函数dump是将Python对象转化为写到磁盘上的二进制文件。<br>json是Python的内置处理json的包，用于序列化json。但这又是什么意思呢？此时的序列化是说将Python的dict类型转化为符合json规范的字符串类型。<br>而marshmallow的序列化，却是将业务对象转化为Python的dict结构，这就很容易搞乱了，在json的语境来说dict是序列化的输入，而在这里却成了输出。<br>这就一度搞得我很乱，一度我只能通过dump与记忆来区分各个序列化场景。但不知为什么在某层的某个节点要这样转一下。</p><p>在定义不清的时候，去查维基的标准定义往往会很有用。</p><blockquote><p>序列化（serialization）在计算机科学的资料处理中，是指将数据结构或物件状态转换成可取用格式（例如存成档案，存于缓冲，或经由网络中传送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p></blockquote><p>所以，一个序列化过程，并不确定它的输入方与输出方究竟是什么类型，而是要根据情况而定。我的感受是，越接近业务本身，越接近Python语言本身，离序列化的输入方就越近；越与业务无关、与语言无关，更接近某协议本身表示的，离序列化的输出方向就越近。</p><p>下面还是上篇文章的简单场景，前端以http调gateway，gateway以thrift rpc调service，来分别看一个在这个请求链路中，对gateway与service来说，分别经历了几次序列化。</p><h2 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h2><p>在gateway中，比如一个flask应用，我总结序列化与反序列化通常有以下几个过程。</p><ol><li>由http请求而来的参数转化为Python的dict，使用flask-restful+webargs(其使用了marshmallw)，将gunicorn或是nginx过来的http协议内的数据反序列化为Python的dict结构；</li><li>gateway要向service发thrift rpc请求，需要将dict结构反序列化为thrift生成的client代码中对应idl中定义的request对象，这里可以抽出一个方法在抽象层面上做同样结构的dict到相应request的序列化，调用方法可能为<code>request = wrap_struct(user_info_dict, NewUserRequest)</code>；</li><li>在请求发出后，拿到rpc的response，得到的依然是由thrift生成的代码中由idl定义的response对象，此时可能需要一个序列化的方法将thrift的response对象序列化为dict结构，<code>create_res = dump_struct(createResponse)</code>；<br>当然，上面的两步也可以使用marshmallow来做，但在gateway层再写一堆schema用来做这个事情真的是有些冗余了，一个更好的办法是使用更加抽象的方式，在反序列化时给定一个dict与相应的已经由thrift生成的request类来生成相应object，同时，可以直接由thrift response生成相同层级结构的dict。</li><li>gateway拿到数据后要给前端http的response，这是一层序列化，flask提供了jsonify将dict转化为相应的结构返回，flask-restful更进了一步，直接在resource函数中返回json，它会自动做这层序列化；<br>在工作中还见到过一些在这一层使用marshmallow，用来做什么呢？设想，当你调用一个service取回一些数据，比如同样是用户的姓名这个字段，在thrift接口中定义为name，调用其他团队的服务，这个不依赖于你，而同时，之前跟前端定的接口中返回用户名为username，相信各位有一定实践经验的同学都有这种字段名转换的经历，在代码中手动处理这种转换真的有些恶心，此时使用marshmallow的dump_to参数来做就会显得比较优雅。<br>若不是这种复杂的情况，直接使用dump_struct回来的数据直接返回给前端即可。</li></ol><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>现在来说一下基础服务层的各个序列化阶段，与gateway还是有着明显的不同的。<br>1- 拿到thrift过来的请求，使用上面提到的dump_struct将thrift response反序列化为dict，方便进行验参等进一步操作；<br>2- 在数据库插入记录前，使用marshmallow的load()方法反序列化，检查各个字段是否符合规则，还见到过一种处理是直接在load()之后插入记录，方法是使用@post_load装饰器，在验参成功后，直接在model中插入记录，并返回给load的调用者，使用起来很自然；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> marshmallow <span class="keyword">import</span> Schema, fields, validate, validates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span>(<span class="params">Schema</span>):</span></span><br><span class="line">    name = fields.Str(required=<span class="literal">True</span>, validate=<span class="keyword">lambda</span> n: n)</span><br><span class="line">    age = fields.Decimal(required=<span class="literal">True</span>, validate=<span class="keyword">lambda</span> n: n &gt; <span class="number">18</span>)</span><br><span class="line">    location = fields.Str(required=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @post_load</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_object</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">from</span> model.user <span class="keyword">import</span> User</span><br><span class="line">        <span class="keyword">return</span> User(**data)</span><br></pre></td></tr></table></figure><p>3- service调model执行查询，对外要先吐出一层json格式的数据，见过一些不够clean的方式是在model的class中定义to_json()方法(其实是返回dict对象)，将model的各个字段填入dict的key与value，大致长下面这个样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_json</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: self.name,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: self.age,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: self.location</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但这个转换用marshmallow来处理明显会更好一些，直接调用<code>UserSchema().dump(record).data</code>即可得到dict对象，这个UserSchema与request进来时load的时候是可以复用的，可以减少编写上面那样不怎么样的代码。同时，上面也提到过，可以使用dump_to来进行model与dict字段的转换，很好用；</p><p>4- service得到的dict对象返回给handler，handler使用<code>wrap_struct(result, UserResponse)</code>来进行反序列化，生成thrift response对象，最终给到thrift去处理。</p><h2 id="网络通信中的序列化"><a href="#网络通信中的序列化" class="headerlink" title="网络通信中的序列化"></a>网络通信中的序列化</h2><p>上面提到的都是往往都是需要开发自己去处理的，但在这个过程中，还有一些显然存在的序列化过程，这里简单提一下。</p><p><strong>uwsgi协议</strong><br>正常情况下，python服务都不可能是裸奔的，它前面往往还有一层uwsgi(或gunicorn)与nginx。<br>uwsgi有它自己的二进制协议，nginx配置后，将http请求序列化为uwsgi协议的传输二进制给到uwsgi服务，uwsgi再将此二进制反序列化为Python对象交给你的flask应用。</p><p><strong>thrift中的序列化</strong><br>上面有很多的地方都提到将request对象交给thrift，然后呢？<br>作为知名的开源rpc框架，它提供了多种序列化机制。支持xml，json等文本协议，亦可使用thrift或是google Protobuf协议，在可读性与性能方面，用户可以自由选择。<br>拿到request的Python对象后，根据不同的序列化协议生成相应格式，最终还是要交给socket来进行数据传输处理。<br>再由socket拿出来后进行反序列化为thrift response。</p><hr><p>上面提到的thrift中很重要的一点(思想)是，thrift的这些处理都是通过idl为基础，使用代码生成器来生成的，开发人员只需要编写idl文件，就可以得到各种语言的直接可以使用的代码。</p><p>由上所述，各种转化真的还蛮多的，难免会有各种重复的字段定义等会出现在项目的各处(在http文档中，在idl中，在marshmallow schema中，在db model中)，参考【<a href="https://guerbai.github.io/2018/08/12/pragmatic-programmer-note/">程序员修炼之道</a>】中的安利，再借鉴thrift的实践构想，我认为在总结清楚这些常见的调用、序列化、验参等规划与比较好的具体实践、代码编写方式后，可以开发一个代码生成器，由一个类似idl的语言，来生成各阶段的本来要由程序员去手动编写的代码，从而大幅提高整体编码效率与代码质量。<br>这肯定是可以实现的，因为thrift已经实现了它。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://guerbai.github.io/2018/08/19/check-param/&quot;&gt;上一篇文章&lt;/a&gt;中说到了验参，现在接着说另一个微服务中的工程性问题，序列化。&lt;br&gt;作为编写业务的程序员，常被戏称为CRUD程序员，会增删改查，给个if else给个for就能混碗饭吃。此话倒不假。&lt;br&gt;在微服务体系下，工作中有时会接触多个项目，各个service与各个gateway，由于维护人员的不同，虽然都是做CRUD的工作，但项目结构与写法却不尽相同。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://guerbai.github.io/tags/python/"/>
    
    <category term="微服务" scheme="http://guerbai.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>说一下Python项目中的验参</title>
    <link href="http://guerbai.github.io/2018/08/19/check-param/"/>
    <id>http://guerbai.github.io/2018/08/19/check-param/</id>
    <published>2018-08-19T09:47:00.000Z</published>
    <updated>2021-11-06T08:53:26.432Z</updated>
    
    <content type="html"><![CDATA[<p>在积累了一定的工作与项目实战经验后，越来越意识到验参的重要性。<br>前几天又重读<a href="https://guerbai.github.io/2018/08/12/pragmatic-programmer-note/">总结了一下【程序员修炼之道】</a>，书中提到，卓有成效的程序员从不相信任何人，包括自己。<br>关于这句话的一个很重要的实践即是在自己编写的程序中，做好验参工作，使对字段的限制与文档一致。这点可以显著得增强系统的稳定性，保护系统的健壮与数据的一致。</p><span id="more"></span><p>在实际工作中，发现验参环节并不是那么容易做好，微服务系统有多层结构，每个服务内代码的组织又是分层的， 在哪些场景与环节进行验参比较实用是自己需要考虑清楚的点。<br>这篇总结一下工作中见到的各Python项目对于验参的各种处理，以及常用的验参的库。</p><h2 id="需要验参的几个场景"><a href="#需要验参的几个场景" class="headerlink" title="需要验参的几个场景"></a>需要验参的几个场景</h2><p>假设项目为一个简单的两层结构，gateway接受浏览器http请求，通过thrift rpc协议调下层service，service将数据写到DB中。</p><p>这样一个简单的调用链可以抽出几处需要验参的地方：</p><ul><li>收到http请求时，对前端传来的参数进行验证，确保前端传来的参数与前端文档中约定的一致；</li><li>service服务代码分层为handler, service, model三层，handler接受到thrift请求，将thrift request对象序列化为dict后，调用service层代码前，需要进行参数验证(包括一些业务上的验参)，确保client端传来的参数与idl中定义的参数规则一致；</li><li>service服务的service层往DB写数据前(包括新增与更新时)需要验参，确保写到数据库中的数据与model文件(orm定义)中定义的规则一致。</li></ul><h2 id="验参如何做"><a href="#验参如何做" class="headerlink" title="验参如何做"></a>验参如何做</h2><h3 id="if-else直接干"><a href="#if-else直接干" class="headerlink" title="if else直接干"></a>if else直接干</h3><p>之前在写一个Java项目的时候，问到组内的一个较有经验的Java开发在Java中验参通常怎么做，怎样是比较地道的写法。<br>他开玩笑说，if else不就好了嘛。(当然，之后还是告诉了我可以用javax.validation中的注解很自然轻易地完成这个任务)</p><p>诚然，if else可以撸出一切。而且的确我也在一些项目中包括刚参加工作时的小公司的代码里见到过这样的做法，不用引入第三方库，直接进行判断，某字段是否存在，某字段是否为None，字段长度是否超长等。<br>这的确可以完成工作，但真的不够clean，每次在函数的前部分都要处理这些东西，代码写出来很丑。若要把这种if抽出来，粒度又太细，同时又要使用比如装饰器这种技术将它和函数本体编织起来，而且不同函数要验证的条件往往又是不一样的，之前写的验证方法可能还要再改以达到通用，这就又要再改引用了这个验证方法的方法，等等情况会出现很多问题，所以并不是一个长久的组织方法。</p><p>下面介绍几个我见过的用于验参的第三方包，可接避免上面那样的重复造轮子。</p><h3 id="marshmallow"><a href="#marshmallow" class="headerlink" title="marshmallow"></a><a href="https://marshmallow.readthedocs.io/en/3.0/">marshmallow</a></h3><p>marshmallow本身是Python中的一个出色的用于做序列化的库，同时也提供了在验参功能。<br>它允许开发者定义一些schema，schema中可以以各种方式(allow_none, required, lambda)来表述一个字段的规则，同时在反序列化(将外部参数转化为领域对象)时，会自动进行验参工作，并将不符合规则的参数统一组织起来，而且允许开发者自己提供个性化的相应报错信息。</p><p>上面说到反序列化，那这位又问了，序列化时它不做验参吗？的确如此，marshmallow的作者认为，序列化是指将自己系统内的数据给提供出去(相当于to_json())，对于它们的质量与来源是我们可以保证的，故不需要在这个时候进行反序列化。<br>但实际情况也并不往往如此，比如我最近接触到的项目，由于之前没有做好验参工作，且表结构较复杂，会有一些存在库中的历史数据其实是少字段的或者是不符合规则的，在这种情况下，可以先将数据取出来，进行序列化生成dict对象，再用dict对象来调用schema.validate(dict)来专门进行验证，从而搜集信息，修补数据。</p><p>它的schema可以按照如下方式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> marshmallow <span class="keyword">import</span> Schema, fields, validate, validates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span>(<span class="params">Schema</span>):</span></span><br><span class="line">    name = fields.Str(required=<span class="literal">True</span>, validate=<span class="keyword">lambda</span> n: n)</span><br><span class="line">    age = fields.Decimal(required=<span class="literal">True</span>, validate=<span class="keyword">lambda</span> n: n &gt; <span class="number">18</span>)</span><br><span class="line">    location = fields.Str(required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @validates(<span class="params"><span class="string">&#x27;location&#x27;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_location</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        valid_locations = [<span class="string">u&#x27;SHANGHAI&#x27;</span>, <span class="string">u&#x27;TOKYO&#x27;</span>, <span class="string">u&#x27;NEWYORK&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> valid_locations:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;Unknown location.&#x27;</span>)</span><br></pre></td></tr></table></figure><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/1ebddc04d1ef280df94d6c63b94e4363.jpg"></p><p>使用marshmallow进行验参</p></div><p>此外，marshmallow还提供了一些常见规则的验证，比如Email，URL来验证字段是否符合规则，不用再去硬写一些让人头疼的正则。它们都继承于Validator类，你也可以继承它来<a href="https://marshmallow.readthedocs.io/en/latest/_modules/marshmallow/validate.html">编写自己的验证规则类</a>来扩展marshmallow的能力，使得一切都很地道、好用。</p><h3 id="webargs"><a href="#webargs" class="headerlink" title="webargs"></a><a href="https://github.com/sloria/webargs">webargs</a></h3><p>在gateway层面，面对http请求，可以使用webargs包来进行参数提取与校验。<br>我们知道，http请求传参有多种可能，比如在url中的<code>?key=value&amp;key2=value2</code>这种格式，此外，post方法传参的可能就更多了，有plan text，application/json等。</p><p>而webargs包便是用来简化这一拿参验参的过程，它让开发者可以通过定义一个schema或是dict的结构来表示自己期望从http中得到哪些参数，以及使用哪些规则。查一下源码的话，很容易发现，它内部也是使用了marshmallow，调用了marshmallow的load函数，最后返回一个dict。<br>这种方式使用起来对开发还是很友好的，举例如下(抄自项目readme)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> webargs <span class="keyword">import</span> fields</span><br><span class="line"><span class="keyword">from</span> webargs.flaskparser <span class="keyword">import</span> use_args</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">hello_args = &#123;<span class="string">&quot;name&quot;</span>: fields.Str(required=<span class="literal">True</span>)&#125;</span><br><span class="line"><span class="comment"># or use schema</span></span><br><span class="line"><span class="comment"># HelloArgs(Schema):</span></span><br><span class="line"><span class="comment">#     name = fields.Str(required=True)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@use_args(<span class="params">hello_args</span>)</span></span><br><span class="line"><span class="comment"># 对应上面</span></span><br><span class="line"><span class="comment"># @use_args(HelloArgs(strict=True))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">args</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + args[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl http://localhost:5000/\?name\=&#x27;World&#x27;</span></span><br><span class="line"><span class="comment"># Hello World</span></span><br></pre></td></tr></table></figure><h3 id="schema"><a href="#schema" class="headerlink" title="schema"></a><a href="https://github.com/keleshev/schema">schema</a></h3><p>说了上面，哪位又问了，marshmallow与webargs所做的验参都不够专一，前者是为序列化服务，后者更多地是为取参同时进行，有些情况下只有两个参数，不想去定义那些schema，感觉好麻烦，而且只想用单一的验参功能，要怎么做呢？</p><p>那么schema就是你想要的。<code>Schema validation just got Pythonic</code><br>它的用法与api比较pythonic，很语义化而且够函数式，写起来还是比较好玩的，不过要注意正确性。<br>在工作中我见过一些同事拿它在service中的handler代码层验参。<br>抄袭项目readme示例代码如下，诸位可以感受下，还是蛮有意思的：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/0e504026866cf110d6a75286b2323d0b.jpg"></p><p>schema示例代码</p></div><hr><p>一定不要小看验参这件事，在大型项目的开发中，可能有很多历史遗留问题，兼容性问题，甚至是来自脚本的恶意请求等。你根本无法确定你编写的代码会被怎样调用，如果这些环节失去了这些保障，线上的复杂情况，会让你的代码在一些匪夷所思的地方报出经典的<code>NoneType</code> error，甚至有些数据库的字段会被莫名其妙地被写为空，却根本不知道它是在何处发生的。这些错误的发生会让开发人员不知所措，措手不及，因为明明在测试时根本没出现过，极度难以调试。<br>等到时候再要加校验，已经很困难了。</p><p>在经历了一些莫明其妙的问题后，我不得不开始重视验参环节，毕竟没吃过亏还是不知道疼。<br>我认为验参环节是一种运行时的assert技术，marshmallow与webargs提供的序列化、取参数的同时进行验参我认为是比较好的方案，它不会让开发者在代码中多写一行专门去调验参函数又能把这件事给做得很棒。</p><p>做好参数验证，是一次请求，一个函数运行，一次持久化成功的第一道保障，client环境太复杂，我们这些写service的还是要保护好自己啊！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在积累了一定的工作与项目实战经验后，越来越意识到验参的重要性。&lt;br&gt;前几天又重读&lt;a href=&quot;https://guerbai.github.io/2018/08/12/pragmatic-programmer-note/&quot;&gt;总结了一下【程序员修炼之道】&lt;/a&gt;，书中提到，卓有成效的程序员从不相信任何人，包括自己。&lt;br&gt;关于这句话的一个很重要的实践即是在自己编写的程序中，做好验参工作，使对字段的限制与文档一致。这点可以显著得增强系统的稳定性，保护系统的健壮与数据的一致。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://guerbai.github.io/tags/python/"/>
    
    <category term="微服务" scheme="http://guerbai.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群一致性Hash效果的代码演示</title>
    <link href="http://guerbai.github.io/2018/08/12/redis-consistent-hashing-code/"/>
    <id>http://guerbai.github.io/2018/08/12/redis-consistent-hashing-code/</id>
    <published>2018-08-12T15:44:00.000Z</published>
    <updated>2021-11-06T08:53:26.439Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务领域，使用Redis做缓存可并不是一件容易的事情。<br>像新浪、推特这样的应用，许许多多的热点数据全都存放在Redis这一层，打到DB层的请求并不多，可以说非常依赖缓存了。如果缓存挂掉，流量全部穿透到DB层，其必然不堪其重，整个系统也会随之瘫痪，后果非常严重。<br>由于缓存数据量很大，Redis快正是快在其基于内存的快速存取，而计算机的内存资源又是十分有限的，故分布式缓存集群面临着伸缩性的要求。</p><span id="more"></span><h2 id="一致性Hash存在的意义"><a href="#一致性Hash存在的意义" class="headerlink" title="一致性Hash存在的意义"></a>一致性Hash存在的意义</h2><p>Redis集群中的各实例之间是并不知道对方的，需要在客户端实现路由法来将key路由到不同的redis节点。</p><p>该路由算法是关键，它必须让新上线的缓存服务器对整个分布式缓存集群影响最小，使得扩容后，整个缓存服务器集群中已经缓存的数据尽可能还被访问到。</p><p>若是使用一般的对key进行一次hash的算法，则会导致扩容后命中率极低。<br>如下表所示，当集群由3个节点扩容到4个节点时，会有75%的key无法命中。</p><table><thead><tr><th>hash(key)</th><th>hash(key)/3</th><th>hash(key)/4</th><th>是否命中</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>是</td></tr><tr><td>2</td><td>2</td><td>2</td><td>是</td></tr><tr><td>3</td><td>0</td><td>3</td><td>否</td></tr><tr><td>4</td><td>1</td><td>0</td><td>否</td></tr><tr><td>5</td><td>2</td><td>1</td><td>否</td></tr><tr><td>6</td><td>0</td><td>2</td><td>否</td></tr><tr><td>7</td><td>1</td><td>3</td><td>否</td></tr><tr><td>8</td><td>2</td><td>0</td><td>否</td></tr><tr><td>9</td><td>0</td><td>1</td><td>否</td></tr><tr><td>10</td><td>1</td><td>2</td><td>否</td></tr><tr><td>11</td><td>2</td><td>3</td><td>否</td></tr><tr><td>12</td><td>0</td><td>0</td><td>是</td></tr></tbody></table><p>这可太糟糕了，当服务器数量为100台时，再增加一台新服务器，不能命中率将达到99%，这和整个缓存服务挂了一个效果。</p><p>而一致性Hash正是为了解决这个问题而出现的，该路由算法通过引入一个一致性Hash环，以及进一步增加虚拟节点层，来实现尽可能高的命中率。<br>使用该算法，当节点由n扩容为n+1时，命中率可保持在n/(n+1)左右。</p><p>关于该算法的具体原理与网上已经有一些说得很透彻的文章，本文不再赘述。<br>下面主要从代码实现及运行的方式来对此算法的效果进行展示。</p><h2 id="本机部署多个Redis节点"><a href="#本机部署多个Redis节点" class="headerlink" title="本机部署多个Redis节点"></a>本机部署多个Redis节点</h2><p>要对一致性Hash进行验证，要做好准备工作，首先要有一个Redis集群。<br>这里我通过使用在本机上部署多个Redis实例指向不同端口来模拟这一形态。</p><p>建立项目目录：<code>$ mkdir redis-conf</code><br>将redis的配置copy一份过来并复制为5份，分别命名为redis-6379.conf~redis-6383.conf。</p><p>需要对其内容进行一些修改才能正常启动，分别找到配置文件中的如下两行并对数字进行相应修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br></pre></td></tr></table></figure><p>然后就可以分别启动了：<code>redis-server ./redis-6379 &amp;</code></p><p>可以使用<code>redis-cli -p 6379</code>来指定连接的redis-server。<br>不妨进行一次尝试，比如在6379设置key 1 2，而到6380 get 1只能得到nil，说明它们是各自工作的，已经满足可以测试的条件。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/fbe23bd067e44e9839b59ee16c889120.jpg"></p><p>不同的节点展示</p></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路是这样的：<br>部署4个节点，从6379到6382，通过一致性Hash算法，将key: 0~99999共100000个key分别set到这4个服务器上，然后再部署一个节点6383，这时再从0到99999开始get一遍，统计get到的次数来验证命中率是否为期望的80%左右(4/5)。</p><p>一致性Hash算法的实现严重借鉴了<a href="https://www.cnblogs.com/xrq730/p/5186728.html">这篇文章</a>，使用红黑树来做数据结构，来实现log(n)的查找时间复杂度，使用FNV1_32_HASH哈希算法来尽可能使key与节点分布得更加均匀，引入了虚拟节点，来做负载均衡。</p><p>建议读者详细看下这篇文章，里面的讲解非常详细易懂。</p><p>下面是我改写过后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.guerbai.io.jedistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JedisProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String[][] redisNodeList = &#123;</span><br><span class="line">           &#123;<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;6379&quot;</span>&#125;,</span><br><span class="line">           &#123;<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;6380&quot;</span>&#125;,</span><br><span class="line">           &#123;<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;6381&quot;</span>&#125;,</span><br><span class="line">           &#123;<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;6382&quot;</span>&#125;,</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Jedis&gt; serverConnectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SortedMap&lt;Integer, String&gt; virtualNodes = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (String[] str: redisNodeList)</span><br><span class="line">       &#123;</span><br><span class="line">           addServer(str[<span class="number">0</span>], str[<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHash</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">       <span class="keyword">int</span> hash = (<span class="keyword">int</span>)<span class="number">2166136261L</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">           hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">       hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">       hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">       hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">       hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">       hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果算出来的值为负数则取其绝对值</span></span><br><span class="line">       <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">           hash = Math.abs(hash);</span><br><span class="line">       <span class="keyword">return</span> hash;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String node)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// 得到带路由的结点的Hash值</span></span><br><span class="line">       <span class="keyword">int</span> hash = getHash(node);</span><br><span class="line">       <span class="comment">// 得到大于该Hash值的所有Map</span></span><br><span class="line">       SortedMap&lt;Integer, String&gt; subMap =</span><br><span class="line">               virtualNodes.tailMap(hash);</span><br><span class="line">       <span class="comment">// 第一个Key就是顺时针过去离node最近的那个结点</span></span><br><span class="line">       <span class="keyword">if</span> (subMap.isEmpty()) &#123;</span><br><span class="line">           subMap = virtualNodes.tailMap(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       Integer i = subMap.firstKey();</span><br><span class="line">       <span class="comment">// 返回对应的虚拟节点名称，这里字符串稍微截取一下</span></span><br><span class="line">       String virtualNode = subMap.get(i);</span><br><span class="line">       <span class="keyword">return</span> virtualNode.substring(<span class="number">0</span>, virtualNode.indexOf(<span class="string">&quot;&amp;&amp;&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addServer</span><span class="params">(String ip, String port)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           String virtualNodeName = ip + <span class="string">&quot;:&quot;</span> + port + <span class="string">&quot;&amp;&amp;VN&quot;</span> + String.valueOf(i);</span><br><span class="line">           <span class="keyword">int</span> hash = getHash(virtualNodeName);</span><br><span class="line">           System.out.println(<span class="string">&quot;虚拟节点[&quot;</span> + virtualNodeName + <span class="string">&quot;]被添加, hash值为&quot;</span> + hash);</span><br><span class="line">           virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">       &#125;</span><br><span class="line">       serverConnectMap.put(ip+<span class="string">&quot;:&quot;</span>+port, <span class="keyword">new</span> Jedis(ip, Integer.parseInt(port)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       String server = getServer(key);</span><br><span class="line">       Jedis serverConnector = serverConnectMap.get(server);</span><br><span class="line">       <span class="keyword">if</span> (serverConnector.get(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.println(key + <span class="string">&quot;not in host: &quot;</span> + server);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> serverConnector.get(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">       String server = getServer(key);</span><br><span class="line">       Jedis serverConnector = serverConnectMap.get(server);</span><br><span class="line">       serverConnector.set(key, value);</span><br><span class="line">       System.out.println(<span class="string">&quot;set &quot;</span> + key + <span class="string">&quot; into host: &quot;</span> + server);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushdb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (String str: serverConnectMap.keySet()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;清空host: &quot;</span> + str);</span><br><span class="line">           serverConnectMap.get(str).flushDB();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">targetPercent</span><span class="params">(List&lt;String&gt; keyList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> mingzhong = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (String key: keyList) &#123;</span><br><span class="line">           String server = getServer(key);</span><br><span class="line">           Jedis serverConnector = serverConnectMap.get(server);</span><br><span class="line">           <span class="keyword">if</span> (serverConnector.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mingzhong++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">float</span>) mingzhong / keyList.size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistencyHashDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       JedisProxy jedis = <span class="keyword">new</span> JedisProxy();</span><br><span class="line">       jedis.flushdb();</span><br><span class="line">       List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">           keyList.add(Integer.toString(i));</span><br><span class="line">           jedis.set(Integer.toString(i), <span class="string">&quot;value&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;target percent before add a server node: &quot;</span> + jedis.targetPercent(keyList));</span><br><span class="line">       JedisProxy.addServer(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;6383&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;target percent after add a server node: &quot;</span> + jedis.targetPercent(keyList));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对参考文章进行了一些改进。<br>首先，参考文章的getServer方法会有些问题，当key大于最大的虚拟节点hash值时tailMap方法会返回空，找不到节点会报错，其实这时应该去找hash值最小的一个虚拟节点。我加了处理，把这个环连上了。<br>下面getHash方法为FNV1_32_HASH算法，可以不用太在意。<br>VIRTUAL_NODES的值比较重要，当节点数目较少时，虚拟节点数目越大，命中率越高。</p><p>在程序设计上也有很大的不同，我写了JedisProxy类，来做为client访问Redis的中间层，在该类的static块中利用服务器节点生成虚拟节点构造好红黑树，getServer里根据tailMap方法取出实际节点的地址，再由实际节点的地址直接拿到jedis对象，提供简单的get与set方法，先根据key拿特定的jedis对象，再进行get, set操作。</p><p>addServer静态方法给了其动态扩容的能力，可以看到在main方法中，通过调用<code>JedisProxy.addServer(&quot;localhost&quot;, &quot;6383&quot;)</code>便直接增加了节点，不需要停应用。<br>targetPercent方法是用来统计命中率用。</p><p>当虚拟节点为5时，命中率约为60%左右，把它加大到100后，可以到达预期的80%的命中率。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/cd2da5a363979167522fb64370007ebd.jpg"></p><p>测试结果</p></div><p>好的，完美。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在微服务领域，使用Redis做缓存可并不是一件容易的事情。&lt;br&gt;像新浪、推特这样的应用，许许多多的热点数据全都存放在Redis这一层，打到DB层的请求并不多，可以说非常依赖缓存了。如果缓存挂掉，流量全部穿透到DB层，其必然不堪其重，整个系统也会随之瘫痪，后果非常严重。&lt;br&gt;由于缓存数据量很大，Redis快正是快在其基于内存的快速存取，而计算机的内存资源又是十分有限的，故分布式缓存集群面临着伸缩性的要求。&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="http://guerbai.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="java" scheme="http://guerbai.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【程序员修炼之道】书摘</title>
    <link href="http://guerbai.github.io/2018/08/12/pragmatic-programmer-note/"/>
    <id>http://guerbai.github.io/2018/08/12/pragmatic-programmer-note/</id>
    <published>2018-08-12T10:27:00.000Z</published>
    <updated>2021-11-06T08:53:26.437Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/5387402/">这本书</a>的确是软件工程领域一本再经典不过的书籍，在尚未开始学习编程的时候便听说过这本书，大约是从萧瓜的答案里。</p><p>在刚参加工作后没多久比现在还要更菜一些的时候初读了这本书，因为全是形而上学的东西，再加上各种牛人的推荐与评价，当时还是感觉这书有丶东西的，而彼时见过的东西不多，各种经验匮乏，使人感同身受、醍醐灌顶的场景并不多，甚至有一些点比如“函数的得墨忒尔法则”也是理解不了的。记得第一遍读过之后感觉不过瘾，还想立即再来一遍，并进行“自省”项目，即根据书中提到的各个点来映射到实际工作开发中的各个点，来进行对比和思考。<br>结果当然是不了了之了。</p><span id="more"></span><p>最近由于总结一些旧书，又把这本200页的书拿出来重读，并进行了一些书摘，记述了本书的整体脉络。<br>这一次，很明显感觉可以结合实际的好建议很多，最后会列出“行动项”，是受阅读启发，可以在工作、日常编码中采取实践的点。</p><h2 id="评价与前言"><a href="#评价与前言" class="headerlink" title="评价与前言"></a>评价与前言</h2><p>这是我唯一不会出借的一本书。 – – Kevin Ruland<br>这本书里虽只包含了很多看似粗浅朴素的道理，实则是若干经验的心血总结。<br>原以为那些嚼烂了的东西，不会再有新味道，但是我错了。– – 云风</p><p>“牛人”其实是备有很多现成代码的，完成这个功能只是把之前积累的封闭良好的可以了。<br>编程大约有三个境界，新手、高手和高不成低不就的中手。<br>编程是一种技艺，一种需要用心学习的技艺。<br>设想你在参加一个会议。或许你在想，这个会议没完没了，你还不如去写程序。而Dave和Andy会想，他们为什么在开会，他们想知道是否可以通过另外的方式取代会议，并决定是否可使某样事情自动化，以使开会的工作推后。<br>这就是Dave和Andy思考的方式。开会并非是某种使他们远离编程的事情。开会就是编程，并且是能够加以改善的编程。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>注重实效的程序员的特征是什么？我们觉得是他们处理问题、寻求解决方案时的态度、风格、哲学。他们能够越出直接的问题去思考，总是设法把问题放在更大的语境中，总是设法注意更大的图景。</p><p>关于<strong>负责</strong>：<br>在所有弱点中，最大的弱点就是害怕暴露弱点。<br>提供各种选择，不要找蹩脚的借口。<br>有时，你其实知道他们会说什么，所以还是不要给他们添麻烦吧。<br>不要说事情做不到；要说明能够做什么来挽回局面。<br>不要害怕提出要求，也不要害怕承认你需要帮助。<br>在你大声说出它们之前，先设法把蹩脚的借口清除出去。如果你必须说，就先对你的猫说。</p><p>关于<strong>软件的熵</strong>：<br>当软件中的无序增长时，程序员们称之为”软件腐烂”。有许多因素会导致，其中最重要的一个开发项目时的心理（或文化）。你开发项目时的心理也可能是非常微妙的事情。<br>不要容忍破窗户。<br>如果没有足够的时间进行适当的修理，就用木板把它钉起来。或许你可以把出问题的代码放入注释，或是显示“未实现”消息，或是用虚拟的数据加以替代。</p><p>关于“石头汤与煮青蛙”的寓言故事：<br>每个人都会护卫他们自己的资源，有时候，这就叫做“启动杂役”。<br>这正是拿出石头的时候。设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大家看，让他们大吃一惊。<br>人们发现，参与正在发生的成功要更容易。让他们瞥见未来，你就能让他们聚集在你周围。<br>做变化的催化剂。<br>要记住大图景，不要因为小事情的累积破坏了士气和团队（而这正是常常发生的）。<br>温水煮青蛙与破窗原理不同，后者是说人们失去与熵战斗的意愿，是因为他们觉察到没有人会在意。而青蛙只是没有注意到变化。</p><p>关于<strong>足够好的软件</strong>：<br>现实世界不会让我们制作出十分完美的产品，特别是不会有无错的软件。时间、技术和急躁都在合谋反对我们。<br>应该给用户以机会，让他们参与决定你所制作的东西何时已足够好。<br>你所制作的系统的范围和质量应该作为系统需求的一部分规定下来。<br>如果你给用户某样东西，让他们及早使用，他们的反馈常常会把你引向更好的最终解决方案。</p><p>编程就像绘画。如果你不懂得应何时止步，所有的辛苦劳作就会遭到破坏。如果你一层又一层、细节复细节地叠加，绘画就会迷失在绘制之中。所以你要知道什么时候止步。<br>不要因为过度修饰和过于求精而毁损完好的程序。继续前进，让你的代码凭着自己的质量站立一会儿。它也许不完美，但不用担心：它不可能完美。</p><p>关于<strong>知识资产</strong>：<br>你的知识和经验是你最重要的职业财富。<br>管理知识资产与管理金融资产非常相似：</p><ol><li>严肃的投资者定期投资– –作为习惯；</li><li>多元化是长期成功的关键；</li><li>聪明的投资者在保守的投资和高风险、高回报的投资之间平衡他们的资产；</li><li>投资者设法低买高卖，以获取最大回报；</li><li>应周期性地重新评估和平衡资产；</li></ol><p>即使投资量很小，习惯自身也和总量一样重要。<br>低买高卖是说，在新兴的技术流行之前学习它可能就和找到被低估的股票一样困难，但所得到的就和那样的股票带来的收益一样。<br>每年至少学习一种新语言。不同语言以不同方式解决相同的问题。通过学习若干不同的方法，可以帮助你拓宽你的思维，并避免墨守成规。<br>学习的过程将扩展你的思维，使你向着新的可能性和新的做事方式拓展。思想的“异花授粉”十分重要；设法把你学到的东西应用到你当前的项目中。</p><p>与他人交谈可以帮助你建立人际网络。<br>出去和与你的当前项目无关的人、或是其他公司的人谈谈技术。<br>所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先计划，让自己在空闲的片刻时间里总有东西可读。<br>P13页有与人打交道的礼节与教养，可学。<br>同时，很重要的一点是，要批判地思考你读到的和听到的。</p><p>关于<strong>交流</strong>：<br>没有有效的交流，一个好想法就只是一个无人关心的孤儿。<br>只有当你是在传达信息时，你才是在交流。你需要了解你的听众的需要、兴趣、能力。<br>WISDOM离合诗—-了解听众：<br><strong>W</strong>hat do you want them to learn?<br>What is their <strong>i</strong>nterest in what you’ve got to say?<br>How <strong>s</strong>ophisticated are they?<br>How much <strong>d</strong>etail do they want?<br>Whom do you want to <strong>o</strong>wn the information?<br>How can you <strong>m</strong>otivate them to listen to you?</p><p>有时候，只要简单地问一句“现在我们可以谈谈……吗?”就可以了。<br>我们常常发现，与制作文档的过程相比，我们制作出的文档最后并没有那么重要。<br>鼓励大家通过提问来交谈，或是让他们总结你告诉他们的东西。把会议变成对话，你将能更有效地阐明你的观点。谁知道呢，你也许还能学到点什么。<br>除非你生活在真空中，你才不需要交流。交流越有效，你就越有影响力。</p><p>关于<strong>DRY</strong>：<br>不要在系统各处对知识进行重复，不要把任何一项知识分散在多个系统组件中。（国家与各种code的表示）<br>不能划入某个明显的责任区域的常用功能和数据可能会被实现多次。<br>我们觉得，可靠地开发软件、并让我们的开发更易于理解和维护的唯一途径，是遵循我们称之为DRY的原则：<br>**系统中的每一项知识都必须具有单一、无歧义、权威的表示。”<br>这不是你是否能记住的问题，而是你何时忘记的问题。<br>我们觉得，这是注重实效的程序员的工具箱里最重要的工具之一。</p><p>在以后的开发过程中，你可以因为性能原因而选择违反DRY原则。这经常会发生在你需要缓存数据，以避免重复昂贵的操作时。其诀窍是使影响局部化。对DRY原则的违反没有暴露给外界。</p><p>关于<strong>正交性</strong>：<br>突然间，你在用一个让人难以置信的复杂系统玩耍，其中每一项改变都会影响所有其他的输入。<br>当任何系统的各组件互相高度依赖时，就不再有局部修正这样的事情。要消除无关事物之间的影响。</p><p>与编写单个的大块代码相比，编写多个相对较小的、自足的组件更为容易。<br>把所需要的任何语境显示地传入模块，代码就会更易于理解和维护。</p><p>你在把电话号码当作顾客的标识符吗？如果电话公司重新分配了区号，会怎么样？不要依赖你无法控制的事物属性。</p><p>也许会让人惊讶，正交性也适用于文档。其坐标轴是内容和表现形式。</p><p>关于<strong>可撤消性</strong>：<br>如果某个想法是你唯一的想法，再没有什么比这再危险的事情了。<br>问题在于，关键决策不容易撤销。（比如数据库表结构的设计，深受其害）<br>与我们开发软件的速度相比，需求、用户以及硬件变得更快。<br>错误由于假定决策是浇在石头上的– –同时还在于没有为可能出现的意外事情做准备。<br>要把决策视为是写在沙滩上的，而不要把它们刻在石头上。大浪随时可能到来，把它们抹去。</p><p>如果在代码中有着糟糕的封装、高度耦合以及硬编码的逻辑或参数，事情也许就是不可能的。</p><p>关于<strong>曳光弹与原型</strong>：<br>并不让人惊奇的是，曳光弹比费力计算更可取。反馈是及时的，而且因为它们工作在与真正的弹药相同的环境中，外部影响得以降至最低。<br>曳光代码并非用过就扔的代码：你编写它，是为了保留它。<br>一旦你在系统的各组件间实现了端到端的连接，你就可能检查你离目标还有多远，一旦你完全瞄准，增加功能将是一件容易的事情。</p><p>原型制作生成用过就扔的代码。你可以把原型制作视为在第一发曳光弹发射之前进行的侦察和情报搜集工作。<br>你可以选择通过原型来研究任何带 有风险的事物。以前没有试过的事物，或是对于最终系统极关键的事物。任何未被证明的、实验性的、或是疑问的事物。任何让你觉得不舒服的事物。<br>原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。那才是原型所作的要点所在。<br>为了学习而制作原型。<br>P42有关于如何制作架构原型的具体事项，在设计架构时可以参考。</p><p>其他<strong>注重实效的途径</strong>：<br>每种语言都含有一系列特性– –所有这些特性都在揭示或遮蔽特定的解决方案。<br>使用领域语言可以靠近问题领域编程。</p><p>通过学习估算，并将此技能发展到你对事物的数量级有直觉的程度，你就能展现出一种魔法般的能力，确定它们的可行性。<br>关于估算，之前还写过<a href="https://www.jianshu.com/p/0d129fa8056c">另一篇文章</a>来描述。<br>如果结果证明估算错了，不要只是耸耸肩走开。找出事情为何与你的猜想不同的原因。也许你选择了与问题的实际情况不符的一些参数。也许你的模型是错的。不管原因是什么，花一点时间揭开所发生的事情。如果你这样做了，你的下一次估算就会更好。</p><p>关于<strong>基本工具</strong>：<br>工具放大你的才干。你的工具越好，你越是能更好地掌握它们的用法，你的生产力就越高。<br>让需要驱动你的采购。<br>唯一的途径是保持基本工具集的“锋利”与就绪。<br>花时间学习使用这些工具，有一天你将会惊奇地发现，你的手指在键盘上移动，操纵文本，却不用进行有意识的思考。工具将变成你双手的延伸。</p><p>持久地存储知识的最佳格式是纯文本。纯文本并非意味着文本是无结构的，比如markdown。<br>大多数二进制格式的问题在于，理解数据所必需的语境与数据本身是分离的。<br>事实上，在异种环境中，纯文本的优点比其所有的缺点都重要。你需要确保所有各方能够使用公共标准进行通信。纯文本就是那个标准。</p><p>GUI的好处是WYSIWYG– –所见即所得。缺点是WYSIAYG– –所见即全部所得。</p><p>选一种编辑器，彻底了解它，并将其用于所有的编辑任务。如果你用一种编辑器（或一组键绑定）进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵：必需的键击将成为本能反应。编辑器将成为你双手的延伸；键会在滑过文本和思想时歌唱起来。这就是我们的目标。<br>对于常见的编辑操作，与鼠标或菜单驱动的命令相比，只使用键击效率更高，因为你的手无须离开键盘。<br>你应该能对编辑器编程，让它执行复杂的、多步骤的任务。可以通过宏或内建的脚本编程语言（例如，Emacs使用Lisp的一个变种）进行这样的编程。</p><p>对于许多开发者，调度本身是一个敏感、感性的话题。你可能会遇到抵赖、推诿、蹩脚的借口、甚或是无动于衷，而不是把它当做要解决的难题发起进攻。<br>bug是你的过错还是别人的过错，并不是真的很有关系。它仍然是你的问题。<br>在你开始调试之前，选择恰当的思维方式十分重要。你须要关闭每天用于保护自我的许多防卫措施，忘掉你可能面临的任何项目压力，并让自己放松下来。最重要的是，记住调试的第一准则：不要恐慌。、<br>如果你目睹bug或见到bug报告的第一反应是“那不可能”，你就完全错了。一个脑细胞都不要浪费在以“但那不可能发生”起头的思路上，因为很明显，那不仅可能，而且生了。<br>在调试时小心“近视”。要抵制只修正你看到的症状的急迫愿望：更有可能的情况是，实际的故障离你正在观察的地方可能还有几步远，并且可能涉及许多其他的相关事物。要总是设法找出问题的根源，而不只是问题的特定表现。</p><p>再现(reproduction)bug<br>不，我们的bug不会真的繁殖（尽管其中有一些可能已经到了合法的生育年龄）。</p><p>程序员可以构建代码生成器。一旦构建好，在整个项目生命期内都可以使用它，实际上没有任何代价。<br>被动代码生成器有一个有趣的特性：它们不必完全正确。你需要在你投入生成器的努力和你花在修正其输出上的精力之间进行权衡。<br>无论何时你发现自己在设法让两种完全不同的环境一起工作，你都应该考虑使用主动代码生成器。<br>为了进行通信，每个代码库将需要某些公共信息– –例如，数据结构、消息格式、以及字段名。要使用代码生成器，而不是重复这些信息。<br>用更简单、语言中立的表示形式来表示它，并为两种语言成生代码，常常更简单。<br>你可以用代码生成器生成几乎任何输出：HTML、XML、纯文本– –可能成为你的项目中别处输入的任何文本。</p><p>关于<strong>偏执</strong>：<br>循环常有香蕉问题（我知道怎样拼写“banana”，但不知道何时停下来– –“bananananananananana…”）、篱笆桩错误（不知道该数桩还是数空）、以及无处不在的off by one错误。</p><p>如果它不可能发生，用断言确保它不会发生。<br>问问你自己：“如果我移走所有的异常处理器，这些代码是否仍然能运行？”<br>如果答案是“否”，那么异常也许就正在被用在非异常的情形中。<br>异常表示即时的、非局部的控制转移– –这是一种级联的goto。</p><p>分配某项资源的例程或对象应该负责解除该资源的分配。<br>以与资源分配的次序相反的次序解除资源的分配。<br>在代码的不同地方分配同一组资源时，总是以相同的次序分配它们。</p><p>关于<strong>解耦</strong>：<br>“羞怯”的工作方式有两种：不要向别人暴露你自己，不要与太多人打交道。<br>这种编码风格极大地增加了我们的类所依赖的类的数目。这为何是一件坏事？因为它增加了系统别的地方的一个无关改动影响你的代码的风险。</p><p>函数的得墨忒尔法则规定，某个对象的任何方法都应该只调用属于以下情形的方法：</p><ol><li>它自身；</li><li>传入该方法的任何参数；</li><li>它创建的任何对象；</li><li>任何直接持有的组件对象。<br>在实践中，这意味着你将会编写大量包装方法，它们只是把请求转发给被委托者。<br>否则，你可能就会发现自己正走在一条通往脆弱、不灵活的未来的道路上。或者，根本没有未来。</li></ol><p>关于<strong>元程序设计</strong>：<br>再多的天才也无法胜过对细节的专注。<br>细节会弄乱我们整洁的代码– –特别是如果它们经常变化。<br>将抽象放进代码，细节放进元数据。<br>P118有关于这种做法的5种好处。<br>针对你目前的项目，考虑应用有多少内容可以从程序自身移往元数据。所得到的“引擎”看起来会是什么样？你能否在不同的应用的语境中复用该引擎？</p><p>位于MVC惯用手法之后的关键概念：既让模型与表示模型的GUI分离，也让模型与管理视图的控件分离。<br>MVC其实是一种通用的编程技术。视图是对模型的一种解释– –它无需是图形化的。控制器更是一种协调机制，不一定要与任何种类的输入设备有关。</p><p>黑板方式的编程消除了对太多接口的需要，从而能带来更优雅更一致的系统。（有点微服务与流程引擎结合的意思）<br>用黑板协调工作流，协调完全不同的事实和因素，同时又使各参与方保持独立、甚至隔离。</p><p>关于<strong>编码</strong>：<br>代码也许能工作，但却没有特别的理由说明它们为何能工作。<br>作为开发者，我们也工作在雷区里。每天都有成百的陷阱在等着抓住我们。我们应该避免造巧合编程– –依靠运气和偶然的成功– –而要深思熟虑地编程。<br>对于你编写给别人调用的代码，良好的模块化以及把实现隐藏在撰写了良好文档的小接口之后，这样一些基本原则都能对你有帮助。<br>不要做历史的奴隶。不要让已有的代码支配将来的代码。</p><p>重写、重做和重新架构代码合起来，称为重构。<br>但如果你无节制地撕毁大量代码，你可能会发现自己处在比一开始更糟的位置上。<br>所以，下次你看到不怎么合理的代码时，既要修正它，也要修正依赖于它的每样东西。要管理痛苦：如果它现在有损害，但以后的损害会更大，你也许最好一劳永逸地修正它。记住软件的熵中的教训：不要容忍破窗户。</p><p>从一开始就把可测试性构建进软件中，并且在把各个部分连接在一起之前对每个部分进行彻底的测试。<br>测试是技术，但更是文化。</p><p>关于<strong>项目</strong>：<br>完美，不是在没有什么需要增加、而是在没有什么需要去掉时达到的。<br>找出用户为何要做特定事情的原因、而水只是他们目前做这件事情的方式，这很重要。<br>需求不是构架。需求不是设计，也不是用户界面。需求是需要。</p><p>抽象比细节活得更长久。<br>要创建并维护项目词汇表– –这是定义项目中使用的专用术语和词汇的地方。项目的所有参与者，从最终用户到支持人员，都应该使用这个词汇表，以确保一致性。<br>墨水刚沾上纸面，就过时了。</p><p>有些约束是绝对的；有些则只是先入之见。绝对的约束必须受到尊重，不管它们看上去有多讨厌或多愚蠢。另一方面，有些外表上的约束也许根本不是真正的约束。许多软件问题都可能具有与之相同的欺骗性。</p><p>编写程序规范就是把需求归约到程序员能够接管的程度的过程。<br>但你可以确信，一旦他们看到运行的系统，你就会被各种变更要求淹没。<br>这里有一个挑战：写一份简短的描述，告诉别人怎样系鞋带。快，试一试。<br>把需求搜集、设计、以及实现视为同一个过程。<br>你越是把规范当作安乐毯，不让开发者进入可怕的编码世界，进入编码阶段就越困难。不要掉进这样的规范螺旋中：在某个时刻，你需要开始编码！</p><p>还有一些开发者，在有许多已沉没项目的大海里漂流，不断抓住最新的时尚，就像是遇到海难的人紧紧抓住飘来的木头一样。每当有新的木头漂过时，他们都会费力地游过去，希望这一块会更好。但到最后，不管漂浮物有多好，之些开发者依然漫无目的地漂流着。</p><p>事实上，大多数形式方法会让你误入歧途，鼓励你在对象之间建立静态关系，而这些对象本来应该动态地编织在一起。<br>如果你遇到一个项目，其哲学是“类图就是应用，其余的只是机械的编码”，你知道，你看到的是一个浸满水的项目团队和一个路途遥远的家。</p><p>因为记忆是随着你年龄的增长而丧失的第二种东西。（第一种是什么？我忘了。）<br>鞋匠的孩子没鞋穿。软件开发人员常常会使用最糟糕的工具来完成工作。<br>P193关于测试什么的具体点。</p><p>文档的表示形式应该独立于其内容。</p><p>本书正文的最后一小段话读来竟然有些热血。<br><strong>当人们在一段代码上看到你的名字时，应该期望它是可靠的、用心编写的、测试过的和有文档的，一个真正的专业作品，由真正的专业人员编写。<br>一个注重实效的程序员。</strong></p><h2 id="行动项"><a href="#行动项" class="headerlink" title="行动项"></a>行动项</h2><ol><li>审视自己开发项目时的心理，特别是当有厌烦情绪的时候；</li><li>考虑项目中的“某扇窗户”是何时破的，是他人的决策所致，还是管理部门的指示；</li><li>推新项目或新工具时，自己先在往锅里扔进石头给人看效果，来做催化剂；</li><li>开发业务系统，用户就在身边，要多与之交流使用感受与期望；</li><li>低买高卖方面，关注最新的技术，比如Julia，比如可以参与翻译工作，或提issue；</li><li>每年至少学习一种新语言；</li><li>空闲时间的阅读计划； </li><li>开始写估算日志；</li><li>代码生成器，由表结构为源数据，到thrift，到各marshmallow，到给前端的接口文档，到restful，到python(model层的代码及基本的CRUD)、java(mybatis与dao层的代码)各版本。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot;&gt;这本书&lt;/a&gt;的确是软件工程领域一本再经典不过的书籍，在尚未开始学习编程的时候便听说过这本书，大约是从萧瓜的答案里。&lt;/p&gt;
&lt;p&gt;在刚参加工作后没多久比现在还要更菜一些的时候初读了这本书，因为全是形而上学的东西，再加上各种牛人的推荐与评价，当时还是感觉这书有丶东西的，而彼时见过的东西不多，各种经验匮乏，使人感同身受、醍醐灌顶的场景并不多，甚至有一些点比如“函数的得墨忒尔法则”也是理解不了的。记得第一遍读过之后感觉不过瘾，还想立即再来一遍，并进行“自省”项目，即根据书中提到的各个点来映射到实际工作开发中的各个点，来进行对比和思考。&lt;br&gt;结果当然是不了了之了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="读书" scheme="http://guerbai.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="软件工程" scheme="http://guerbai.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Patti与他们相遇</title>
    <link href="http://guerbai.github.io/2018/08/05/just-kids/"/>
    <id>http://guerbai.github.io/2018/08/05/just-kids/</id>
    <published>2018-08-05T15:17:00.000Z</published>
    <updated>2021-11-06T08:53:26.435Z</updated>
    
    <content type="html"><![CDATA[<p>之前看了Patti Smith的回忆录【<a href="https://book.douban.com/subject/26939269/">只是孩子</a>】。</p><blockquote><p>帕蒂初抵纽约那年，正是嬉皮风潮勃发的“爱之夏”，鲍勃.迪伦、滚石、吉姆.莫里森风华正盛，詹妮斯.乔普林和吉米.亨德里克斯一夕成名– –两年后，他们将和帕蒂在切尔西酒店短暂相遇。</p></blockquote><p>这些相遇，以及Patti对他们的形容与一些小事的回忆、描述，在我读来颇有意思。之前只是听过他们各自的歌曲，而Patti的回忆给了这一切以关联，通过一个当事人(作为同行、听众、朋友)的视角来描述这些人，把所有的故事串了起来，他们的每一句交谈，Patti所描绘的每一个场景都能让我遐想联翩许久。</p><span id="more"></span><p>以下是对书中内容的一些摘录。</p><h2 id="Allen-Ginsberg"><a href="#Allen-Ginsberg" class="headerlink" title="Allen Ginsberg"></a>Allen Ginsberg</h2><p>我转身一看，竟是艾伦.金斯堡。我从没见过他，但我们这位伟大诗人和行动主义者的脸，我不会认错。看着卷曲的深色大胡子衬托下的那双尖锐的深色眼睛，我点了点头。艾伦补足了那十美分，还请我喝一杯咖啡。我默默地随着他坐到桌边，然后甩开腮邦子吃起三明治来。<br>艾伦做了自我介绍……，他突然俯过身来紧盯着我。“你是女的？”他问。<br>“是啊，”我说，“有问题吗？”<br>他只是笑着：“抱歉，抱歉，我把你当成一个美男了。”<br>我立马明白了是怎么一回事。<br>“呃，那意思是三明治得还你是吗？”<br>“不用还，吃吧，是我失误。”</p><p>……<br>后来，艾伦成了我的良师益友。我们经常回忆起两人的初次邂逅，有一次他还问我会怎样形容我们的相遇。“我会说，你在我饥饿的时候喂饱了我。”我告诉他。确实如此。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/4921f63805015f511106009e321b5cda.jpg"></p><p>与金斯堡</p></div><h2 id="Tom-Verlaine"><a href="#Tom-Verlaine" class="headerlink" title="Tom Verlaine"></a>Tom Verlaine</h2><p>那支乐队(Television)乐风粗糙不羁、古怪，富于个性和感染力。他们的一切我都喜欢，那种痉挛式的动作，鼓手行云流水的爵士范儿，散漫却高潮迭起的音乐结构。右边那个高个的古怪吉他手让我感觉很亲切：浅黄色的头发，优雅修长的手指握着吉他琴颈，就像要把它掐死一样。那人叫汤姆.魏尔伦，他肯定看过《地狱一季》这本书。<br>在演出间歇，我和汤姆没有谈诗歌，而是聊起了新泽西的森林、特拉华清冷的海滩和西部天际盘旋的飞碟。结果发现，我俩竟在相距二十分钟车程的地方长大，听着同样的唱片，看着同样的卡通，而且都爱《一千零一夜》。休息结束，“电视”回到了舞台上。理查德.劳埃德抄起了他的吉他，奏响了《华盖之月》的第一个乐句。</p><p>我们想再加一把吉他来表现对自由不顾一切的渴望，乐队选中了汤姆.魏尔伦。我琢磨着如何能打动汤姆的心，特别做了一番打扮，想必一个从特拉华出来的小伙子是会懂的：……。<br>我的穿戴是否打动了汤姆不得而知，反正他满腔热情地加入了我们的录音队伍。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/9be29077ba2b99fcbd172a2ba58685e1.jpg"></p><p>与魏尔伦</p></div><h2 id="Jim-Morrison"><a href="#Jim-Morrison" class="headerlink" title="Jim Morrison"></a>Jim Morrison</h2><p>我们没钱看演出，不过罗伯特在离开“东菲尔莫”之前，给我搞到过一张“大门”乐队的演出通行证。他们的第一张专辑曾让我和珍妮特听得如饥似渴，没能和珍妮特一块去看几乎让我产生了罪恶感，但在看吉姆.莫里森演出时，我的反应却怪怪的。周围的人似乎都被惊呆了，我却以一种冷冷的、十分清醒的意识观察着他的一举一动。我对于这种感觉的记忆，比对演出本身更清晰。看着吉姆.莫里森，我感觉，干这个我也能行。我也说不上为什么会这么想。我的经历里，没有哪样能证明存在这种可能性，但我心中怀有这样的自负。我对他同时产生了亲切感和藐视，我能感受到他的害羞和他无上的自信，他散发着一种混合着美、自我厌恶和神秘痛苦的气息，就像西海岸来的圣徒塞巴斯蒂安。我的这种反应让自己都有点脸红，当问起“大门”如何时，除了说他们很棒，我什么也说不出来。</p><p>一场危险的暴风雨把大家都赶回了家，不过我没走，后来经洛杉矶回到纽约。我就是在那儿看到了一个巨大的“大门”乐队新专辑【洛杉矶女人】的广告牌，上面是一个被钉在电线杆上的女人。一辆车从身边驶过，车上的电台里传出他们的新单曲<riders on the storm>。我自责，我几乎忘记了吉姆.莫里森对我产生过多么重要的影响，是他引领我走上了把诗歌融入摇滚的道路，我决定要去买这张专辑，为他写一首有力量的作品。<br>但我刚回到纽约，他在巴黎去世的消息就从欧洲慢慢传开了。有那么一两天，没有人能确定究竟发生了什么。吉姆死在了他的浴缸里，死因神秘。那是七月三日，布莱恩.琼斯的祭日。</p><p>七月十三日这天是个星期五，在格林街与运河街的夹角，地下导演杰克.史密斯住的阁楼顶上，我在吉姆.莫里森的纪念会上做了朗诵。那是属于我的演出，到场的都和我一起赞美吉姆.莫里森。</p><p>开往巴黎的列车上平淡无奇。我一度发现自己在流泪。一到巴黎，我便登上去拉雪兹神父公墓的地铁，因为在回纽约之前我还有一件事要做。雨又下起来了。我在公墓墙外的一家花店前停下，买了一小把风信子，开始找寻吉姆.莫里森之墓。……在那个没有标志的墓前，摆放着朝圣者们的礼物：塑料花、烟头、空了一半的威士忌酒瓶、断了线的念珠和奇怪的护身符。译成法语的歌词涂鸦围绕着他：Cest lafin, mon merveilleux ami。这就是终点了，我亲爱的朋友。<br>我感到一种别样的轻松，一点也不悲伤。我感觉他可能会从薄雾中无声地走来，轻拍我的肩膀。似乎他葬在巴黎就对了。<br>……<br>我有种不安的感觉，如果不赶紧离开我就会变成石头，变成一尊手持风信子的雕像。<br>……<br>突然间，她转向我，用英语粗暴地喊道：“美国人！干吗不去尊敬你们的诗人？”<br>那时的我很累。那时的我二十六岁。四周那些粉笔写下的留言，就像眼泪一般在雨中消融，在护身符、香烟、吉他拨片下面汇成涓流。在这块埋葬着吉姆.莫里森的土地上，漂浮的花瓣就像是从奥菲莉亚的花束上散落的。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/7e72f8417d97aab5af8ac695c75447d7.jpg"></p><p>Jim墓前</p></div><h2 id="Janis-Joplin"><a href="#Janis-Joplin" class="headerlink" title="Janis Joplin"></a>Janis Joplin</h2><p>我穿着圆点花纹的人造丝海军蓝长裙，戴着草帽，这是我的“伊甸园之东”造型。我左手的桌边，詹妮斯.乔普林正和她的乐队谈笑风生；我的右前方，是格雷丝.斯利克和“杰弗逊飞机”以及“乡下人乔和鱼”的成员；面对门的最后一张桌上坐着吉米.亨德里克斯，他戴着帽子，埋头吃着东西，对面坐了一位金发女郎。音乐家在这里遍地都是，在他们跟前的桌子上，堆满了虾和青酱、西班牙海鲜饭、桑格里酒壶和龙舌兰酒瓶。</p><p>通过他（博比）我认识了……等音乐家。他们就像鹅群一样，等待詹妮斯.乔普森的到来。能进入这群人的私密世界，我唯一的通行证就是博比的一句话，而他的话是无可置疑的。他把我以“诗人”的身份介绍给詹妮斯，从那以后詹妮斯就经常喊我“诗人”。</p><p>那群热忱的音乐家到了切尔西，他们常会拿着木吉他到詹妮斯的套房里去。我获准去看他们排练她新专辑的歌曲。詹妮斯是这只摩天轮的皇后，坐在她的安乐椅上，拿着一瓶金馥力，哪怕是在下午。迈克尔.波拉德总是伴其左右，他们就像一对心心相印的双胞胎，语言模式都一样，每句话都加个“哥们”。我坐在地板上，听克里斯.克里斯托弗森唱起她的《我和博比.麦吉》，詹妮斯唱和声。我本是冲着这样的时刻去的，但那时太年轻，正专注于自己的思绪，几乎捕捉不到这些瞬间。</p><p>因为中央公园的那场大雨，詹妮斯.乔普林在八月又回来了，她看起来开心极了。詹妮斯对录音充满了期待，围着紫红、粉色和紫色的羽毛围巾华丽地进了城，她去哪儿都围着它们。……詹妮斯几乎整晚都和一个她喜欢的帅哥待在一起，但就在打烊之前，那人却和一个更漂亮的谄媚女人溜掉了。詹妮斯受了很大刺激，“这种事老是发生在我身上，哥们，又是一个寂寞之夜了。“她在博比的肩头抽泣着。<br>博比叫我把她送回切尔西，照顾着点他。我把她送回她的房间，在她哀叹自己命不好的时候陪在她身旁。走之前，我告诉她我为她写了一首小歌，并且唱给她听。<br>……<br>她说：”这就是我，哥们。这就是我的歌。“我要走了，她对着镜子整理着她的围巾，”我看起来怎么样，哥们？“<br>”你就像颗珍珠，”我回答，“珍珠般的姑娘。”</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/ffef95235f968e217269ff5f7429d032.jpg"></p><p>Janis Joplin在Chelsea Hotel</p></div><h2 id="Jimi-Hendrix"><a href="#Jimi-Hendrix" class="headerlink" title="Jimi Hendrix"></a>Jimi Hendrix</h2><p>那是柯川离开的夏天，是《水晶船》的夏天。手无寸铁的花童举起了双臂，中国试爆了氢弹，吉米.亨德里克斯在蒙特雷烧了他的吉他，调幅电台播放了《比利.乔颂歌》……在这种辗转变幻的荒凉氛围里，一次偶然的遭遇改变了我的生命轨迹。<br>这是我遇到罗伯特.梅普尔索的夏天。</p><p>这是一个臭名昭著的地方……，吉米.亨德里克斯常在这儿泡着，俱乐部关张后，他接手了这地方，把它建成了第八街52号深处的顶级录音棚。<br>……<br>能去那儿让我很兴奋。我戴上草帽朝市中心走去，但当我到了地方，却怎么也不敢进去了。正巧吉米.亨德里克斯出现在楼梯上，发现我像个土气的怪人一样坐在那里，他咧嘴笑了。他得赶飞机去伦敦参加怀特岛音乐节。我告诉他我胆太小了不敢进去，他温和地笑着，说可能和别人以为的正相反，他很腼腆，参加派对也总让他紧张。他在楼梯上陪我待了一会儿，告诉我他想要用这个录音棚做些什么。他梦想着能聚集世界各地的音乐家，这样他们就能带着他们的乐器来到伍德斯托克，在地上坐成一圈，弹啊，弹啊。什么调、什么速度、什么旋律都不重要，他们能一直弹，直弹到度过不和谐阶段，找到一种共同的语言。最终，他们将在他的新录音棚里，把这种抽象的世界性音乐录下来。<br>“和平的语言。你喜欢吗？”我喜欢。<br>我不记得我是不是真的走进了那间录音棚，不过吉米的梦想再也不可能实现了。</p><p>我们走在蒙帕纳斯大道上，我看到了令我痛心的新闻头条：Jimi Hendrix est mort. 27 ans.我知道这是什么意思。<br>吉米.亨德里克斯再也没机会回到伍德斯托克创造世界性的语言了，他也再不可能到“电动女士”去录音了。我感到我们痛失了一会好友，我回想起他的背景，那绣花的马甲，还有他迈上楼梯的长腿，那也是他最后一次迈进这方天地。</p><p>十月三日……，我们又一起哀悼了这位吉他诗人的离去，在一起谈论他的过程中那得一点点安慰。<br>然而在第二天晚上，我们还将在约翰尼的房间里再一次地相互慰藉。我的日记里只写了几个字：詹妮斯.乔普森。她因毒品使用过量死在了洛杉矶“里程碑”酒店的105房间，时年二十七岁。</p><p>我们录音的B棚在“电动女士”的后部，有一个小的八轨调音台。正式开始之前，我对着麦克风轻唤了一声“嗨，吉米”。</p><p>接下来的五个星期，我们录制并缩混了我的第一张专辑《马群》。吉米.亨德里克斯再也不能回来创造他的新音乐语言了，但他留在了这间录音棚里的，是他对我们未来文化之声的所有希望和共鸣。<br>从我踏进录音间的第一刻起，这些感触就浮现在脑海中：摇滚乐拯救我于苦涩的青春期，我的感激之情；我跳舞时体尝到的快乐；我在为自己所作所为负责的过程中日积月累的道德力量。</p><p>这些东西在《马群》里被重新编码，也作为对前行者的一次致敬。在《鸟园》里，我们从年轻的彼得.赖克着手，他在等待父亲威廉.赖克从天而降解救他。在《打破它》里，我和汤姆.魏尔伦写了一个梦，像普罗米修斯般被绑缚的吉姆.莫里森突获自由。在《大地》里，野孩子的意象和亨德里克斯走向死亡的步履合在一处。而《挽歌》，纪念了所有那些人，过去、现在和将来，那些我们已经失去、正在失去和终将失去的人。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/dc92f8a697daaab981bfbd4666968531.jpg"></p><p>Jimi在演奏【星条旗永不落】</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前看了Patti Smith的回忆录【&lt;a href=&quot;https://book.douban.com/subject/26939269/&quot;&gt;只是孩子&lt;/a&gt;】。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;帕蒂初抵纽约那年，正是嬉皮风潮勃发的“爱之夏”，鲍勃.迪伦、滚石、吉姆.莫里森风华正盛，詹妮斯.乔普林和吉米.亨德里克斯一夕成名– –两年后，他们将和帕蒂在切尔西酒店短暂相遇。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些相遇，以及Patti对他们的形容与一些小事的回忆、描述，在我读来颇有意思。之前只是听过他们各自的歌曲，而Patti的回忆给了这一切以关联，通过一个当事人(作为同行、听众、朋友)的视角来描述这些人，把所有的故事串了起来，他们的每一句交谈，Patti所描绘的每一个场景都能让我遐想联翩许久。&lt;/p&gt;</summary>
    
    
    
    
    <category term="摇滚乐" scheme="http://guerbai.github.io/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
    <category term="读书" scheme="http://guerbai.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>几种宏的描述与展示</title>
    <link href="http://guerbai.github.io/2018/07/22/many-macro/"/>
    <id>http://guerbai.github.io/2018/07/22/many-macro/</id>
    <published>2018-07-21T16:12:00.000Z</published>
    <updated>2021-11-06T08:53:26.436Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名编程人员，或者是一个游戏玩家，再或者是一个大学生在上大一计算机课的时候，可能会有不少人像我一样会(可能并非出于本愿)接触到“宏”这个东西，然后感觉一脸茫然，觉得它属于高阶知识，不好理解，不知所然。<br>就单看这个字，宏，给人感觉上就是比较抽象的太过于技术化，不像“一致性”这样的技术圈词语，有其自解释性。同时，由于它在不同的领域出现并且发挥着不同的作用，便更加让人一头雾水。</p><span id="more"></span><p>这篇相当于一个总结和笔记，记录我所遇到过的宏，并进行一些展示，希望对“宏”这个“高阶功能”有一个全局的认识和把握。</p><h2 id="宏是什么"><a href="#宏是什么" class="headerlink" title="宏是什么"></a>宏是什么</h2><p>Wiki百科中说，宏是一种批量处理的称谓，是一种抽象，这种机制通常暗示着将<em>小命令或动作</em>(name of a macro)转化为一系列指令。<br>它的用途在于自动化频繁使用的序列或者是获得一种更强大的抽象能力。</p><p>这种描述很容易让人联想起<em>函数</em>，在这一点上，我认为宏与函数在抽象、可复用的思想上是相似的，但却绝不是同一种东西，而这种不同，由于各编程语言对宏的支持程度差别很大，那么这个答案在各情景下也是不同的。<br>在下面的各种语言中，我会分别解释这两种事物的差异。</p><h2 id="编程语言对宏的支持"><a href="#编程语言对宏的支持" class="headerlink" title="编程语言对宏的支持"></a>编程语言对宏的支持</h2><h3 id="C语言中的宏"><a href="#C语言中的宏" class="headerlink" title="C语言中的宏"></a>C语言中的宏</h3><p>在C语言与C++中可以使用宏(在大一上C语言课程时应该都接触过)，但这种支持只是很浅而片面的，使用方式很有限。</p><p>在Gnu文档里有一个解释得比较清晰而简单的关于C语言中宏的定义：</p><blockquote><p>A macro is a fragment of code which has been given a name. Whenever the name is used, it is replaced by the contents of the macro. </p></blockquote><p>给一块儿代码起一个名字，当这个名字被调用时，这个名字会被替换为之前定义的那一块儿代码。</p><p>那么，在C语言中，宏与函数有何不同呢？<br>首先，函数的使用方式称为<em>调用</em>，是基于调用栈运行的；而如上描述，宏则是基于一种<em>字符串的替换</em>。<br>宏往往是在编译时会被处理，而函数则是在运行时。</p><p>在C中，使用<code>#define</code>来定义一个宏，如<code>#define TWO 2</code>，即用TWO来代替2。那么，C的预处理器会将代码中所有独立的TWO替换为2，这种替换文本的过程称为<em>宏展开</em>，这种展开不进行计算，它只是按照指令进行文字替换操作。</p><p>上面这种定义常量的方式称为Object-like macros，使用它就像使用一个数据对象，此外，C中还有另一种常见的宏，像函数一样被使用的function-like macros，这种区分主要是基于使用场景上的。</p><p>比如可以定义一个求平方的宏<code>#define SQUARE (X) (X) * (X) </code>，在写程序时可以在需要求平方的地方像使用函数一样使用它<code>SQUARE(a)</code>。<br>这一堆奇怪的括号也说明了它的使用方式是替换，若不加括号，在替换过程中可能会出现一些意想不到的情况，比如使用<code>SQUARE(x+2)</code>，则会变成<code>x+2*x+2</code>，又根据运算符的优先级问题，肯定得不到原本想要的结果。</p><p>此外，C语言还规定，#define一个宏不能超过一行，可以说这种支持真的是很有限，无法让人感到宏的强大与乐趣。</p><h3 id="Scheme语言中的宏"><a href="#Scheme语言中的宏" class="headerlink" title="Scheme语言中的宏"></a>Scheme语言中的宏</h3><p>不像C语言对宏的唯唯诺诺、施展不开拳脚的支持，Scheme作为Lisp的一个著名方言，可以说是对宏支持得最全面、彻底的语言(之一？)了。<br>有人说正是宏的存在，使得Lisp是另一种语言(其他所有的算另一种)，这不禁让人想起了才高八斗的形容。</p><p>在Scheme中，宏不再仅仅是一种简单的预处理阶段的文本替换(现在看起来多捞哦)，在这里它可以做到很神奇的事情，玩出很多花来，从而给lisp提供了生成语法、对代码进行元编程的能力。</p><p>lisp语言中数据与代码都是s-expression，宏与函数在scheme中的区别也在于此，首先，宏不会像函数一样，会展开它收到的参数表达式，只有在这种前提下，宏才能完成它的功能，返回一个s-expression(即动态生成代码)，而该表达式会被解释器立即执行，这相比之下，函数则是直接返回一个值，两者相去甚远，显然宏的抽象级别更高一些。</p><p>Wiki中对Scheme的宏系统有如下一段较为晦涩的描述：</p><blockquote><p>…宏的行为如同是函数对自身程序文本的变形，并且可以应用全部语言来表达这种变形。一个C宏可以定义一段语法的替换，然而一个Lisp的宏却可以控制一节代码的计算。<br>…<br>获得了控制代码的执行顺序（见<a href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97" title="惰性计算">惰性计算</a>和<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E9%99%90%E5%88%B6%E5%87%BD%E6%95%B0&action=edit&redlink=1" title="非限制函数（页面不存在）">非限制函数</a>）的能力，使得新创建的语法结构与语言内建的语法结构不可区分。例如，一种Lisp方言有cond而没有if，就可以使用宏由前者定义后者。</p></blockquote><p>在这里介绍一下，如何用macro给Scheme自定义语法。</p><p>我们知道python有个可以同时迭代两个list的函数为zip，使用方法为：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/c6840e9b2f8118f17cc3f744ed1461b6.jpg"></p><p>python zip展示</p></div><p>而Scheme本身是没有zip这种语法的：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/18c69b41e19d3fc877c86781d3bd9ab3.jpg"></p><p>Scheme无zip</p></div><p>那现在我们定义一个zip的宏，来实现这个语法并且试用一下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> zip</span><br><span class="line">  (<span class="name"><span class="builtin-name">syntax-rules</span></span> ()</span><br><span class="line">    ((<span class="name">_</span> ((<span class="name">variables</span> lists) ...)</span><br><span class="line">        body ...)</span><br><span class="line">     (<span class="name"><span class="builtin-name">for-each</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (variables ...) body ...) lists ...))))</span><br></pre></td></tr></table></figure><p>上面define-syntax显然是一个关键字，zip表示这个宏的名字，body为使用宏时传入的参数，for-each为Scheme中可以对list进行迭代的函数。</p><p>效果如下：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/8e9fa91fde6af8efe62e6dc4250d198b.jpg"></p><p>zip效果</p></div><h3 id="SweetJS"><a href="#SweetJS" class="headerlink" title="SweetJS"></a>SweetJS</h3><p>对，你没有看错，JS也可以通过某种方式来实现对宏的支持，这又一次证实了Atwood’s Law(any application that can be written in JavaScript, will eventually be written in JavaScript.)，想象力真是无限的。</p><p>有一个包叫<a href="https://www.sweetjs.org/">Sweet.js</a>，它给JS提供了如上所示的像Scheme一样定义语法的功能。<br>它的hello world是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syntax hi = <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> #<span class="string">`console.log(&#x27;hello, world!&#x27;)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line">hi</span><br></pre></td></tr></table></figure><p>它需要经过特殊的编译，不能直接使用node运行，需要先编译，再用node运行：<br>sjs hello.js后输出为console.log(‘hello, world!’)，这是编译后成生的js代码，再用node去运行它就行了。</p><p>这里就很明显了，并不是简单定义了一个函数一样的东西，因为使用它时，hi后面并没有括号，而的确是定义了自己的语法。</p><p>我们还可以用它来实现一个自己的let语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax mylet = function (ctx) &#123;</span><br><span class="line">  let ident = ctx.next().value;</span><br><span class="line">  ctx.next(); // eat `=`</span><br><span class="line">  let init = ctx.expand(&#x27;expr&#x27;).value;</span><br><span class="line">  return #`</span><br><span class="line">    (function ($&#123;ident&#125;) &#123;</span><br><span class="line">      $&#123;ctx&#125; // &lt;2&gt;</span><br><span class="line">    &#125;($&#123;init&#125;))</span><br><span class="line">  `</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mylet bb8 = 233;</span><br><span class="line">console.log(bb8);</span><br></pre></td></tr></table></figure><p>运行sjs mylet.js &gt; my_let.js，将编译后生成的代码存入另一个文件，另一个文件内容为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">bb8_5</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bb8_5);</span><br><span class="line">&#125;)(<span class="number">233</span>);</span><br></pre></td></tr></table></figure><p>此时，再用node my_let.js来运行，即可得到233这个结果，可以说是够神奇了吧。</p><h2 id="编辑器宏"><a href="#编辑器宏" class="headerlink" title="编辑器宏"></a>编辑器宏</h2><p>编辑器宏与上面的在感观上是迥然不同的，它是对你的操作进行记录，然后将一系列动作进行重放。</p><h3 id="Word中的宏"><a href="#Word中的宏" class="headerlink" title="Word中的宏"></a>Word中的宏</h3><p>假设，在word中经常要键入自己的邮箱，并改变字体大小、颜色，现将这个操作使用宏记录下来，可以对自己的一连串操作进行复用。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/ad9a5b355732bd3a5768d35bf18b6fcb.gif"></p><p>使用Word录制宏</p></div><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>做为一个写代码的，Vim最起码要知道怎么退出吧。<br>作为编辑器之神，它当然也提供了宏的支持，使用它常常可以使编辑效率大增，而我在实际工作中，便常常使用它的宏录制功能，来帮我完成一些无聊的批量处理工作。</p><p>这里举两个例子，其一是生成数字1到100，每个一行，当然不是每行每行输入了，接下来是表演时间：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/fefe0b5da6035820185d1cf035877094.gif"></p><p>生成1-100的数字</p></div><p>那现在，需要将它们转为python的list，且每个都变为字符串格式，操作如下：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/f34cc94517f5cdbd1cfd1fa8a0b6498c.gif"></p><p>生成num_list</p></div><p>在vim normal模式下，按qa开始录制宏，表示把宏录到a这个寄存器里，一番操作之后，按q结束。<br>第一次调用宏要使用@a，可触发，之后使用@@可以触发上次运行的宏，在前面加数字98表示运行98次，这样整个下来操作就会有丶厉害了。</p><h3 id="Emacs中的宏"><a href="#Emacs中的宏" class="headerlink" title="Emacs中的宏"></a>Emacs中的宏</h3><p>刚说过了编辑器之神，现在是神的编辑器了。<br>Emacs不仅可以像上面Vim那样录制宏，现场操作，还可以将录制的宏生成一段elisp函数，存放在配置里，这样不用每次用的时候都去录制。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/4c1b170e851fb4609d8515f37c735d91.gif"></p><p>使用Emacs定义宏，并生成elisp配置代码</p></div><p>全是通过elisp函数来操作的，使用Emacs与Vim还是有着很大的区别的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h3><p>宏病毒常见于微软的Office产品中，上面介绍了在Word中录制宏，其实它的本质是生成一段VBA代码，这相当于提供了VBA的编程接口，那么，在这段代码中编入恶意代码运行，便成为病毒。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/c6b6f85a60bcefe9bea27371f8dc2c08.jpg"></p><p>生成的VB代码</p></div><p>此外，同样是微软的Outlook由于拥有scripting特性，更是成为了宏病毒的重灾区。<br>该特性使得宏病毒能够获得Outlook用户地址簿中存储的联系人地址，通过向这些地址发送E-mail将病毒体广泛传播。</p><p>关于宏病毒的判断、防范与清除在长时间的实践中积累了一定的经验，具体的可以进一步去网上冲浪获取。</p><h3 id="游戏中的宏"><a href="#游戏中的宏" class="headerlink" title="游戏中的宏"></a>游戏中的宏</h3><p>在去年大热了很久的吃鸡游戏中，外挂、鼠标宏等不公平游戏行为，被广大玩家深恶痛绝。那么鼠标宏是什么呢？<br>我们知道在游戏中，有些操作是有一定难度的，比如盲僧的回旋踢，不一定是每次都能秀到的(有时候会把自己秀到…)，那么设想一下，把这段操作操作一次记录到鼠标和键盘中，每次Q中人，按一个按键触发之前录制好的这一系统操作，成功率就会大大提高。<br>同样，比如打lol要挂机，但站在泉水里一动不动，会被系统发现并惩罚，那么可以将鼠标来来回回点的操作录制成一个宏，然后肯定还有方式让它一直触发，这样，就可以利用鼠标宏挂机而躲过系统惩罚。</p><p>甚至，在wow这样的游戏中，由于有些操作太过于复杂，游戏本身提供了操作控制的宏录制功能(看到这个点我真的是惊了！)，例如同时激活2种以上的法术，施法的同时用游戏中的聊天系统发送信息等等，有很大的发挥空间。</p><p><strong>但是</strong>，这些都是歪门邪道，&lt;头号玩家&gt;告诉我们，玩儿游戏过程中那种最纯粹的投入与快乐才是最真实最重要的，利用鼠标宏、键盘宏进行不公平游戏无疑很严重地毁掉了这种纯粹，即使可能获得一时的心里上的不健康的愉悦，但最终毁掉的还是自己的、队友的、对方的很多人的游戏体验，更是毁掉你喜爱的游戏的生存时间与社区生态。</p><hr><p>总结，以及回顾各种语言及软件的用法耗费了我比较大的精力，但限于自己水平及阅历的有限，我知道自己的表述并没有展露出神奇的宏的全貌以及全部的典型用法。<br>希望多多交流和指正。</p><p><strong>参考</strong><br><a href="https://zh.wikipedia.org/wiki/%E5%B7%A8%E9%9B%86">维基百科：宏</a><br><a href="https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function">How to save a keyboard macro as a Lisp function?</a><br><a href="https://en.wikibooks.org/wiki/Scheme_Programming/Looping">Scheme Programming/Looping</a><br><a href="https://www.zhihu.com/question/50712432">鼠标宏是什么</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一名编程人员，或者是一个游戏玩家，再或者是一个大学生在上大一计算机课的时候，可能会有不少人像我一样会(可能并非出于本愿)接触到“宏”这个东西，然后感觉一脸茫然，觉得它属于高阶知识，不好理解，不知所然。&lt;br&gt;就单看这个字，宏，给人感觉上就是比较抽象的太过于技术化，不像“一致性”这样的技术圈词语，有其自解释性。同时，由于它在不同的领域出现并且发挥着不同的作用，便更加让人一头雾水。&lt;/p&gt;</summary>
    
    
    
    
    <category term="折腾" scheme="http://guerbai.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>使用Emacs做GTD软件</title>
    <link href="http://guerbai.github.io/2018/07/13/org-mode-gtd/"/>
    <id>http://guerbai.github.io/2018/07/13/org-mode-gtd/</id>
    <published>2018-07-12T17:54:00.000Z</published>
    <updated>2021-11-06T08:53:26.437Z</updated>
    
    <content type="html"><![CDATA[<p>作为著名的“操作系统”，Emacs当然可以用来做GTD软件(使用org-mode)。<br>平心而论，这个方案还是可行的，首先，data放到Onedrive文件夹里就可以实现云备份与多机同步，此外，用户还可以使用它进行自定义的多维度的数据统计，社区甚至还提供了专门的<a href="https://github.com/lolownia/org-pomodoro">org-pomodoro</a>插件，这么一来番茄工作法也可以施行，在完成一个番茄钟时还可以让电脑发出“叮”的声音，对一个纯文本编辑器来说，这些实在是有点过于强大了。</p><span id="more"></span><p>此篇介绍一下如何使用Emacs做GTD软件，里面有一些微小的经验与细节，讲实话这种方案上手难度还是蛮大的，只推荐给想要装B的同学、闲得蛋疼的同学或者本身使用Emacs而尚未使用时间管理的同学实用。</p><h2 id="原材料"><a href="#原材料" class="headerlink" title="原材料"></a>原材料</h2><ul><li><a href="https://www.gnu.org/software/emacs/download.html">最新版Emacs</a>;</li><li><a href="http://spacemacs.org/">Spacemacs配置文件</a>;</li><li><a href="https://github.com/lolownia/org-pomodoro">org-pomodoro插件</a></li></ul><p>我使用的Emacs是25.3版本，在装Spacemacs过程或者org-pomodoro插件过程中可能会碰到一些问题，如何成功安装这些原材料并不在本篇准备讲述的范围之内，请参考各自文档，应该都比较容易解决掉的。<br>Spacemacs与org-pomodoro非必选，仅使用原生的Emacs经过简单的配置即可作为GTD使用，使用配置文件会使整个体验更好，但上手难度相对来说更大了一些，而pomodoro仅提供番茄工作法的支持，若不需要的话亦可不选择。</p><p>如果这些问题便没有耐心去解决或者觉得浪费时间，那么说明本方案不适合你，还是及早收手为好。</p><h2 id="设置data目录"><a href="#设置data目录" class="headerlink" title="设置data目录"></a>设置data目录</h2><p>使用GTD软件肯定是要产生一定的用户数据的(之后称用户数据为data)，那么它一定要被放在某个地方，为了云存储、多机同步的目的，可以选择在Onedrive文件夹下建立org目录来存放data。</p><p>由于配置不是三两行就能写完的，故专门建立一个文件夹做GTD的配置，编辑配置文件~/.emacs，使Emacs自动加载它时载入GTD的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(load-file &quot;~/my-agenda.el&quot;)</span><br></pre></td></tr></table></figure><p>在配置文件中，指定data的存放目录，并绑定进入agenda的快捷键，这里配置为Ctrl-C a来触发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(setq org-agenda-files &#x27;(&quot;~/OneDrive/org&quot;))</span><br><span class="line">(global-set-key (kbd &quot;C-c a&quot;) &#x27;org-agenda)</span><br></pre></td></tr></table></figure><p>经过这几行配置，已经初有效果了：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/de685efd50179e9f214f22af916e9b93.gif"></p><p>通过Ctrl-C a进入agenda view</p></div><p>进入agenda-view后，可以看到一些操作提示，通过一个按键可以快速查看一天、一周、所有、关键字搜索、标签搜索等任务。</p><h2 id="新增任务"><a href="#新增任务" class="headerlink" title="新增任务"></a>新增任务</h2><p>配置好data目录后，再配置具体要将信息写于哪个文件，可以配置多个文件，出于简化，这里将所有的agenda todo写入~/OneDrive/org/todo.org文件下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(setq org-default-notes-file &quot;~/onedrive/org/todo.org&quot;)</span><br><span class="line">(global-set-key (kbd &quot;C-c r&quot;) &#x27;org-capture)</span><br></pre></td></tr></table></figure><p>上面设置的快捷键C-c r，Emacs会提示根据todo template来创建一个任务。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/7d9bdaecfc2615620e6926e75cdf26e7.gif"></p><p>新建一个任务</p></div><p>创建任务之后，可以在agenda-view的list all TODO entries里看到刚刚添加的任务。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/c1f8ec124d3080e61e9f6736766c99e8.jpg"></p><p>all todo entries</p></div><p>但是这是在日任务、周任务里是看不到的，需要为它添加起始、结束时间，操作分别为C-c C-s，C-c C-d。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/d48d7ce9e083c43f1da36b17155d5d90.gif"></p><p>为任务添加起始、结束时间并在week中查看</p></div><h2 id="配置任务Template"><a href="#配置任务Template" class="headerlink" title="配置任务Template"></a>配置任务Template</h2><p>见上面新建一个任务时的图，新建任务是基于Template的，我们利用比如大写的TODO字样是Emacs自带的Template。同时，org-agenda支持用户配置自己的template。</p><p>在配置中加入如下代码，可以增加时间管理中充当<em>收集篮</em>角色的template：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;; capture;</span><br><span class="line">(setq org-capture-templates</span><br><span class="line">      &#x27;((&quot;t&quot; &quot;Todo&quot; entry (file+headline org-default-notes-file &quot;待办事项&quot;)</span><br><span class="line">         &quot;* TODO %?\n  %i\n  %a&quot;)</span><br><span class="line">        (&quot;s&quot; &quot;收集篮&quot; entry (file+headline org-default-notes-file &quot;Quick notes&quot;)</span><br><span class="line">         &quot;* Quick notes %?\n %i\n %a&quot;)</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/cc940cfd3399ced810f2194c4ccc7094.jpg"><br><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/25d80b958e6d68d6dd4c88d627b2b91b.jpg"></p><p>利用这个机制，可以编写自己的template，对自己的使用情景进行分类，可以使操作更加多样化，满足更大的想象力。</p><h2 id="周期性任务"><a href="#周期性任务" class="headerlink" title="周期性任务"></a>周期性任务</h2><p>有些任务是周期性、经常没有结束的，比如我使用RSS看各种资讯，每3天看一次，时间在当天中午吃过饭13:00到14:00一个小时，那么可以在设置任务起始时间时，加入周期性的标记即可（在指定的时间后面加上：+3d），效果在week-view中很明显，会周期性地出现。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/27310eb4c8224e272857cc276cb9b775.jpg"></p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/390214585c84e4360442c7284cb1c93c.jpg"></p><h2 id="按Tag进行分组与搜索"><a href="#按Tag进行分组与搜索" class="headerlink" title="按Tag进行分组与搜索"></a>按Tag进行分组与搜索</h2><p>使用Tag进行将事物进行分组是一种常见的管理模式，在org-agenda中，新建一个任务时可以为它加Tag，方法为在任务描述后面加上<code>:tag1:tag2:</code>这样的标记。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/1aa1cfc887dcbac69d0c6d6f5878f39b.jpg"></p><p>在上图中可以看到，将<em>学agenda</em>归为<em>学习</em>和<em>工具</em>标签下，这样，就可以通过标签搜索的功能将该Tag下所有的任务搜出来。</p><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/359a416a1ae6e1efe6b2ad247c41a276.jpg"></p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/260f60aadbb1d5ff39d49b00723ae43b.jpg"></p><p>分别按不同的标签搜索</p></div><p>同时，agenda-view还提供各种搜索的方式，可以根据关键字，是否完成等条件搜索。<br>各个搜索入口在agenda-view描述得很清楚：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/7daf1a5fd426b2156ae2864bc0a481b6.jpg"></p><p>agenda-view按键说明</p></div><h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>根据四象限工作法，各任务是有优先级的，org-agenda当然提供了为任务设计不同优先级的功能，为A，B，C三个不同的级别，操作为将光标放到任务的一行上，按Shift-上、下键，即可调整该任务优先级。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/60af48df68a43afb843b684985a91eba.gif"></p><p>切换任务优先级</p></div><p>如果觉得自带的ABC不够用的话，还可以自己定义优先级，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(setq org-highest-priority ?A)</span><br><span class="line">(setq org-lowest-priority  ?D)</span><br><span class="line">(setq org-default-priority ?D)</span><br><span class="line">(setq org-priority-faces</span><br><span class="line">      &#x27;((?A . (:background &quot;red&quot; :foreground &quot;white&quot; :weight bold))</span><br><span class="line">        (?B . (:background &quot;DarkOrange&quot; :foreground &quot;white&quot; :weight bold))</span><br><span class="line">        (?C . (:background &quot;yellow&quot; :foreground &quot;DarkGreen&quot; :weight bold))</span><br><span class="line">        (?D . (:background &quot;DodgerBlue&quot; :foreground &quot;black&quot; :weight bold))</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure><p>上述配置定义了最低优先级为D，且为默认优先级，同时设置了颜色，使得各优先级区分度更高，配置过后效果图如下：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/8ab1bed940db119814ed1822a4eb941f.gif"></p><p>有底色与自定义优先级的展示</p></div><h2 id="获取Chrome链接"><a href="#获取Chrome链接" class="headerlink" title="获取Chrome链接"></a>获取Chrome链接</h2><p>有一种常见的场景为在浏览网页时看到一篇文章一时看不完，要把它记下来之后再看，这个时候需要复制链接，再粘贴到Emacs中，这个过程比较烦人，牛人子龙山人为此提供了如下的配置，通过AppleScript，再增加一个相应的Template，可以使新增该Template的任务时自动去Chrome抓取url并粘贴在Emacs中，可以说是非常神奇了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(defun my/insert-chrome-current-tab-url()</span><br><span class="line">  &quot;Get the URL of the active tab of the first window&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (insert (my/retrieve-chrome-current-tab-url)))</span><br><span class="line"></span><br><span class="line">(defun my/retrieve-chrome-current-tab-url()</span><br><span class="line">  &quot;Get the URL of the active tab of the first window&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (let ((result (do-applescript</span><br><span class="line">                 (concat</span><br><span class="line">                  &quot;set frontmostApplication to path to frontmost application\n&quot;</span><br><span class="line">                  &quot;tell application \&quot;Google Chrome\&quot;\n&quot;</span><br><span class="line">                  &quot;set theUrl to get URL of active tab of first window\n&quot;</span><br><span class="line">                  &quot;set theResult to (get theUrl) \n&quot;</span><br><span class="line">                  &quot;end tell\n&quot;</span><br><span class="line">                  &quot;activate application (frontmostApplication as text)\n&quot;</span><br><span class="line">                  &quot;set links to &#123;&#125;\n&quot;</span><br><span class="line">                  &quot;copy theResult to the end of links\n&quot;</span><br><span class="line">                  &quot;return links as string\n&quot;))))</span><br><span class="line">    (format &quot;%s&quot; result)))</span><br><span class="line"></span><br><span class="line">;; capture;</span><br><span class="line">(setq org-capture-templates</span><br><span class="line">      &#x27;((&quot;t&quot; &quot;Todo&quot; entry (file+headline org-default-notes-file &quot;待办事项&quot;)</span><br><span class="line">         &quot;* TODO %?\n  %i\n  %a&quot;)</span><br><span class="line">        (&quot;s&quot; &quot;收集篮&quot; entry (file+headline org-default-notes-file &quot;Quick notes&quot;)</span><br><span class="line">         &quot;* TODO %?\n  %i\n %U&quot;</span><br><span class="line">         :empty-lines 1)</span><br><span class="line">        (&quot;c&quot; &quot;Chrome&quot; entry (file+headline org-default-notes-file &quot;Quick notes&quot;)</span><br><span class="line">         &quot;* Later see: %?\n %(my/retrieve-chrome-current-tab-url)\n %i\n %U&quot;</span><br><span class="line">         :empty-lines 1)</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure><p>效果如下：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/3e3057f5283f1e4ab6ba3ce870de6dc5.gif"></p><p>自动抓取Chrome url创建任务</p></div><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>使用Emacs可以对任务完成情况及时间使用情况进行统计。<br>对各Tag、各种类型的任务的耗时进行统计，统计出来的结果可能是一个人意想不到的（比如竟然在重要的事情上花的时间不及不重要却相对简单的事情的时间的一半），这种统计对之后的时间安排有导向性，在时间管理中还蛮重要的。</p><p>开始一个任务时的操作被称为clock in，结束计时被称为clock out，操作分别为C-c C-x C-i与C-c C-x C-o，在一个任务上可多次计时，最终Emacs会自动处理总的时间。</p><p>在todo.org文件下，C-c C-x C-r可以生成一个动态的报表，之所以称为动态，意思是它生成一次，就呆在那里，下次来看，可以会根据之间的变化进行统计值的更新，手动刷新操作为C-c C-c。</p><p>C-c C-x C-r命令会生成一个org中的代码块，可针对各种关心的维度，比如各tag，各优先级等，进行统计项的筛选，每个相同的统计表保留一份即可。</p><p>由于我已经好久没有用这个东西统计了，没有数据，这里盗<a href="https://www.zhihu.com/question/34299750/answer/58303458">一个网上的图</a>，来说明这个功能的强大。</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/610e4b7b3873cc17ea7f0dbaf9870106.jpg"></p><p>统计图示例</p></div><p>上面clocktable后面的:maxlevel :scope等均为筛选项，具体参数及用法见<a href="https://orgmode.org/manual/The-clock-table.html#The-clock-table">文档</a>，可以构造自己关心的统计表格，并且随时更新哟！</p><h2 id="org-pomodoro"><a href="#org-pomodoro" class="headerlink" title="org-pomodoro"></a>org-pomodoro</h2><p>番茄工作法是一个著名的专注高效的GTD实践，org-pomodoro插件可以提供一个25分钟（可自定义）的倒计时器，到时间会提醒你休息一下，然后再吃下一个番茄。</p><p>安装好插件后，要为一个task开启一个番茄钟，只需要在task上M-x: org-pomodoro就开始了：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/f55c6a20538ea1bd525b04baa5e06ce3.jpg"></p><p>tab栏上的倒计时钟</p></div><p>一声“叮”响之后，这个番茄钟就结束了，会进入break阶段：</p><div align=center><p><img src="https://raw.githubusercontent.com/guerbai/scene/main/blog/e7be1c036fa1122e22a208184ce7affa.jpg"></p><p>break5分钟</p></div><p>如果要关掉一个误打开的番茄钟，使用S-M: (org-pomodoro-kill)。</p><h2 id="做项目管理"><a href="#做项目管理" class="headerlink" title="做项目管理"></a>做项目管理</h2><p>有篇很棒的使用org做项目管理的文章，我觉得已经算是很好的实践了，在此处分享一下。<br><a href="https://www.devalot.com/articles/2008/07/project-planning">Behind the code: project planning</a></p><hr><p>以上是所有功能的展示充分说明了Emacs有能力作为一个GTD软件并且在某些方面还要做得比其他好，但缺点也较明显，上手难度太大，要记的快捷键太多，有些点过于原始，要熟练应用还需要一段不小的时间适应与折腾，在长处和缺点之间要综合考虑。<br>这一趟总结下来，有很多地方之前都用过但现在已经不记得了要再去查，费了不少的时间，但这对我而言也是一次较全面的巩固。</p><p>有趣的是，这么一番总结下来，感觉自己又有一点想用Emacs了，毕竟还是酷的呀。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为著名的“操作系统”，Emacs当然可以用来做GTD软件(使用org-mode)。&lt;br&gt;平心而论，这个方案还是可行的，首先，data放到Onedrive文件夹里就可以实现云备份与多机同步，此外，用户还可以使用它进行自定义的多维度的数据统计，社区甚至还提供了专门的&lt;a href=&quot;https://github.com/lolownia/org-pomodoro&quot;&gt;org-pomodoro&lt;/a&gt;插件，这么一来番茄工作法也可以施行，在完成一个番茄钟时还可以让电脑发出“叮”的声音，对一个纯文本编辑器来说，这些实在是有点过于强大了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="折腾" scheme="http://guerbai.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="GTD" scheme="http://guerbai.github.io/tags/GTD/"/>
    
  </entry>
  
</feed>
