---
title: "不同层级的缓存"
updated: 2017-12-11 01:37:42
---
    
这篇还是源于之前去七牛面试时，被问到了Etag的相关问题，当时答得不怎么样。    
结合之前看的CSAPP中关于缓存的一章，遂自己提出了一个问题想要彻底搞清楚：    
> 一个HTTP请求，从浏览器发出到服务器返回，可能会经历多少不同层级的缓存，以及每一层是如何运作的。    
    
## HTTP缓存    
**强缓存**    
强缓存不会发送请求到服务器，根据header中的Expires或者Cache-Control来判断是否命中。    
    
Expires为绝对时间，第一次请求时，Response中携带Expires，客户端将该资源与该字段存下来，之后请求时比较时间。    
通过修改客户端时间，会对是否过期的结果产生影响。    
    
Cache-Control为相对时间，单位为秒，如：Cache-Control:max-age=31536000。均以客户端时间为准。不缓存时，此字段设为"no-cache"。    
两者都存在时，Cache-Control优先级高。    
    
对这两个字段的设置，既可由应用程序来设置，亦可由Nginx来设置。    
    
对于图片，CSS这样的静态资源，适合用强缓存，动态数据不适用。此处的问题在于确实需要更新客户端这些被缓存内容时的方案，具体可参考：[大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)    
    
**协商缓存**    
发送请求到服务器，服务器告诉客户端可以使用客户端中的缓存(而不是返回数据)，浏览器进行加载。    
缓存命中时，服务器返回304，显示为Not Modified。    
    
协商缓存是利用的是[Last-Modified，If-Modified-Since]和[ETag、If-None-Match]这两对Header来管理的。    
    
前者机制为：    
第一次请求时，Response中返回Last-Modified；客户端下次请求中传If-Modified-Since(即Last-Modified的值)给服务器，服务器拿该字段与资源的最后修改时间进行判断，若未更新则返回304。    
同样，传值为绝对时间，客户端可以篡改时间。    
    
后者机制为：    
第一将请求时，Response返回Etag，为所请求资源的一个唯一标识(比如可以用md5实现)，该资源变化，则唯一标识也会跟着改变；再请求时If-None-Match为Etag值，服务端进行判断。    
    
这两者之间，Etag更可靠，优先级高。    
    
## 业务缓存    
当HTTP缓存均未命中时，有可能会命中业务缓存。    
    
应用中的业务数据以及接口均有冷热之分，对于热点数据或热点接口的返回值，可使用Redis或Memcahced做缓存。    
    
两者类似，均为：C编写，内存中存数据，key-value机制。    
通过散列算法，可进行O(1)时间复杂度的取值。    
内存中取数据比MySQL、MongoDB等数据库读磁盘要快。    
均可做分布式、集群，两者有所差异，有各自的实现方案，不予赘述。    
    
这种方式很常用，容易出问题的点在于存取操作代码通常不在一处，应用多得话会比较分散，可能会出现资源更新后，缓存并未及时更新的bug。    
建议使用一些机制(比如ORM的onUpdate)的钩子函数，将更新缓存的代码统一组织，使其在数据变动时自动更新。    
同时，要注意某Key的超时时间。    
在RED遇到的更新机制为，对于某类Key，使用Azkaban做定时任务，一分钟更新一次。    
    
## 数据库缓存    
当业务缓存未命中时，往往会去数据库中通过查询语句读数据，此处以较熟悉的MySQL为例。    
    
**执行计划缓存**    
此处缓存的不是数据，而是查询的*执行计划*。    
使用explain可以很好得查看某SQL的执行计划，通常只对SELECT有效。    
SQL亦是一种语言，数据库软件需要语法分析，优化，生成执行计划；生成执行计划比较耗费时间。    
某数据库软件查询流程：    
![](http://osriq34d5.bkt.clouddn.com//17-12-11/2777766.jpg)    
数据库软件将执行计划通过某种结构缓存在内存中，可以很好得优化query性能，同时，也对内存的要求有所增加。    
    
**查询结果缓存**    
除了缓存执行计划外，MySQL还可以缓存完整的SELECT结果。当查询命中该缓存时，MySQL会立即返回结果，可以跳过解析、优化和执行等阶段。    
    
缓存存放在一个引用表中，通过一个哈希值引用(应该是一种key-value结构降低时间复杂度)。    
这个哈希值包括如下因素：查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能会影响返回结果的信息。    
MySQL直接使用SQL语句和客户端发送过来的其他原始信息来判断缓存是否命中。    
注意，判断时，MySQL不会去解析SQL语句，而是做字符层面的匹配。同时，若查询中包含一些不确定的数据，如NOW()或CURRENT_DATE()时，查询亦不会被缓存。    
    
执行计划缓存也是完全存储在内存中的，默认关闭，可通过配置打开。    
使用时要做好权衡，需要做好减少碎片及提升缓存使用率的工作。    
    
显然，以上两者的顺序为，先判断是否命中查询结果缓存，命中则返回，若未命中，则判断是否命中执行计划缓存。    
    
## 硬件缓存    
这个阶段趋于底层，到了操作系统(以Linux为例)机制的层面，涉及到了硬件层面的存储器的层次结构。    
    
这里要提到**局部性原理**。    
一个编写良好的计算机程序，倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性即为局部性原理。    
现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。    
在硬件层，引入了*高速缓存存储器*的小而快速的特点来保存最近被引用的指令和数据项，从而提高数据访问I/O速度；    
操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。    
    
结合这种原理，存储器有了这样的层次结构。    
![Alt text](http://wdxtub.com/images/14612515449186.jpg)    
如上图所式，寄存器运行最快，CPU在一个时钟周期内便可访问到它。    
之后每一层，都是其下一层的缓存。    
本地文件可作为web页面的缓存(浏览器将html缓存起来)，内存又是本地磁盘的缓存，直到最快的寄存器。    
    
可以看出本文的分析就该金字塔而言是从下往上，现在是到了内存这一层。    
所以此处，需要着重说一下内存的缓存，SRAM。这样，便可贯通道路，走上金字塔 。    
SRAM通常有两到三层，搭载在芯片上，又称为CPU缓存。    
当处理器发出内存访问请求时，会先去这一层缓存中查找，不命中时，才会交给总线(处理器进入等待)，由其访问内存，先填充SRAM，再返回给处理器。    
    
这一层的缓存是硬件行为。    
    
读取时可能出现缓存未命中，分三种类型：    
1. 强制性失效；    
2. 冲突失效；    
3. 容量失效。    
    
读取的规则大致如下：    
![Alt text](http://wdxtub.com/images/14612642281687.jpg)    
SRAM具体结构及匹配细节可参考CSAPP，此处不过多展开。    
    
CPU往内存写入时，根据写入是否命中有着不同的策略。    
命中：    
> Write-through: 命中后更新缓存，同时写入到内存中    
Write-back: 直到这个缓存需要被置换出去，才写入到内存中    
    
未命中：    
> Write-allocate: 载入到缓存中，并更新缓存    
No-write-allocate: 直接写入到内存中，不载入到缓存    
    
通常的搭配是：    
Write-through + No-write-allocate    
Write-back + Write-allocate    
其中第一种可以保证绝对的数据一致性，第二种效率会比较高(通常情况下)。    
    
如此，便算是攀登到了顶峰。    
    
以上！    
    
## 参考    
1. [HTTP 缓存机制一二三](https://zhuanlan.zhihu.com/p/29750583)    
2. [浏览器缓存知识小结及应用](http://www.cnblogs.com/lyzg/p/5125934.html)    
3. [深入理解计算机系统](https://book.douban.com/subject/5333562/)    
4. [高性能MySQL](https://book.douban.com/subject/23008813/)    
5. [【不周山之读薄 CSAPP】叁 内存与缓存](http://wdxtub.com/2016/04/16/thin-csapp-3/)